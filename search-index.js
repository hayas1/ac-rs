var searchIndex = JSON.parse('{\
"aclib":{"doc":"Rust practice: Data structure and Algorithms","t":[0,0,0,0,0,0,0,0,14,14,14,14,14,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,8,10,10,11,10,10,10,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,0,0,0,0,0,8,3,11,11,11,10,11,10,11,10,11,11,11,11,10,11,11,11,11,11,11,0,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,8,3,11,11,11,11,10,11,10,11,11,11,11,10,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,0,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,0,0,5,5,0,0,0,6,0,0,5,0,0,5,5,5,5,0,0,0,0,5,5,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,3,4,4,4,13,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,0,0,0,0,0,0,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,5,5,5,5,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,12,11,11,11,11,11,11,5,5,5,5,0,0,0,5,5,5,5,5,5,0,0],"n":["algo","collections","cumsum","dic_order","graph","integer","knapsack","macros","max","mean","min","prod","sum","bisect","bound","compress","distance","inversion","sort","two_pointers","bisect","bisect_left","bisect_left_by_key","bisect_right","bisect_right_by_key","bisect_unit","initial_indices","log_ceil","log_floor","sqrt_ceil","sqrt_floor","bisect_right","lower_bound","upper_bound","coordinate_compress","hamming","levenshtein","manhattan_chebyshev","hamming_distance","levenshtein_distance","chebyshev_distance","chebyshev_distance_2d","manhattan_distance","manhattan_distance_2d","rotate_45","inversion_number","inversion_number_with","bubble_sort","heap_sort","insertion_sort","merge_sort","quick_sort","selection_sort","two_pointers","counter","heap","linkedlist","segtree","sorted_vec","trie_tree","unionfind","Counter","count","counted","from","most_common","new","remove","non_recursive","recursive","MinHeap","borrow","borrow_mut","down_heap","from","from","into","len","new","peek","pop","push","try_from","try_into","type_id","up_heap","BHeapSet","borrow","borrow_mut","down_heap","from","from","heapify","into","len","new","peek","pop","push","try_from","try_into","type_id","up_heap","singly","LinkedList","append","borrow","borrow_mut","dequeue","drop","enqueue","extend","from","into","is_empty","len","new","peek_head","peek_tail","pop","push","try_from","try_into","type_id","custom_tree","lazy_segtree","non_copy","non_recursive","recursive","segtree","Monoid","SegmentTree","bisect","borrow","borrow_mut","from","from","identity","indices","into","into","leaf_offset","len","new","operation","query","try_from","try_into","type_id","update","update_with","addtree","AddTree","borrow","borrow_mut","from","into","leaf_offset","new","num_of_leaf","propagation","query","recursive_query","recursive_update_range","try_from","try_into","type_id","update_range","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","from","index","index_mut","into","leaf_offset","query","swap","try_from","try_into","type_id","update","update_parents","update_with","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","index","into","leaf_offset","new","num_of_leaf","query","swap","try_from","try_into","type_id","update","update_with","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","into","is_root","leaf_offset","left_child","new","num_of_leaf","parent","query","recursive_query","recursive_update","right_child","root","try_from","try_into","type_id","update","update_with","Monoid","SegmentTree","bisect","borrow","borrow_mut","from","identity","indices","into","into","leaf_offset","len","new","operation","query","try_from","try_into","type_id","update","update_with","SortedVec","borrow","borrow_mut","extend","from","from_iter","index","insert","into","iter","max_elements","min_elements","new","try_from","try_into","type_id","TrieTree","borrow","borrow_mut","contains","fmt","from","insert","into","new","remove","try_from","try_into","type_id","merge_technique","smooth_unionfind","unionfind","with_petgraph","MergeTechnique","borrow","borrow_mut","find","from","into","new","same_group","size","try_from","try_into","type_id","union","UnionFind","borrow","borrow_mut","connected_components","equiv","find","from","into","new","root","size","try_from","try_into","type_id","union","UnionFind","borrow","borrow_mut","find","from","into","new","try_from","try_into","type_id","union","cumsum1d","imos1d","CumSum","borrow","borrow_mut","from","from_iter","from_iter","indices","interval_sum","into","try_from","try_into","type_id","with_data","Imos1D","borrow","borrow_mut","from","into","new","sum_timing","try_from","try_into","type_id","bfs","next_permutation","kth_dic_order","next_permutation","algo","with_petgraph","without_petgraph","NodeId","dijkstra","euler_tour","undirected_neighbors","one_to_many","one_to_one","dijkstra","from_to_indices","dijkstra","euler_tour","arbitrary","diameter","grid","search","diameter_of_tree","field_to_directed_grid","dijkstra","search","structure","MinHeapRecord","borrow","borrow_mut","cmp","eq","equivalent","from","into","ne","partial_cmp","try_from","try_into","type_id","AdjacencyList","Directed","Undirected","Unweighted","Weight","Weighted","add_node","bfs","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","dfs","dijkstra","dijkstra","from","from","from","from","from","index","index","into","into","into","into","into","neighbors","new_unweighted_directed","new_unweighted_undirected","new_weighted_directed","new_weighted_undirected","nodes_len","remove_node","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","weight","0","counting","devisors","gcd","modint","modulo","prime","rational","sieve","sort","Counting","borrow","borrow_mut","combination","combination_with_repetition","factorial","from","into","new","permutation","try_from","try_into","type_id","devisors","devisors_pair","gcd_recursive","lcm_recursive","ModInt","add","add_assign","borrow","borrow_mut","clone","clone_into","cmp","eq","equivalent","fmt","fmt","from","into","mul","mul_assign","ne","new","partial_cmp","sub","sub_assign","to_owned","to_string","try_from","try_into","type_id","ex_euclid","inverse_mod_mul","mod_pow","mod_pow_u64","factorization","fast_primes","Rational","add","add_assign","borrow","borrow_mut","clone","clone_into","cmp","common","div","div_assign","eq","equivalent","fmt","fmt","from","into","irreducible","mul","mul_assign","new","partial_cmp","sub","sub_assign","to_owned","to_string","try_from","try_into","type_id","SieveOfEratosthenes","borrow","borrow_mut","euler_phi","factorization","from","into","is_prime","min_primes","new","primes","sieve","try_from","try_into","type_id","counting_sorted","counting_sorted_with","radix_sorted","radix_sorted_with","dp","meet_in_the_middle","solver","dp_weight_with_backtrack","knapsack_dp_value","knapsack_dp_value_solve","knapsack_dp_weight","knapsack_half_enumerate","knapsack","compare","summation"],"q":["aclib","","","","","","","","","","","","","aclib::algo","","","","","","","aclib::algo::bisect","","","","","","","","","","","aclib::algo::bound","","","aclib::algo::compress","aclib::algo::distance","","","aclib::algo::distance::hamming","aclib::algo::distance::levenshtein","aclib::algo::distance::manhattan_chebyshev","","","","","aclib::algo::inversion","","aclib::algo::sort","","","","","","aclib::algo::two_pointers","aclib::collections","","","","","","","aclib::collections::counter","","","","","","","aclib::collections::heap","","aclib::collections::heap::non_recursive","","","","","","","","","","","","","","","","aclib::collections::heap::recursive","","","","","","","","","","","","","","","","","aclib::collections::linkedlist","aclib::collections::linkedlist::singly","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree","","","","","","aclib::collections::segtree::custom_tree","","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::lazy_segtree","aclib::collections::segtree::lazy_segtree::addtree","","","","","","","","","","","","","","","","aclib::collections::segtree::non_copy","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::non_recursive","","","","","","","","","","","","","","","","","","aclib::collections::segtree::recursive","","","","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::segtree","","","","","","","","","","","","","","","","","","","","aclib::collections::sorted_vec","","","","","","","","","","","","","","","","aclib::collections::trie_tree","","","","","","","","","","","","","aclib::collections::unionfind","","","","aclib::collections::unionfind::merge_technique","","","","","","","","","","","","","aclib::collections::unionfind::smooth_unionfind","","","","","","","","","","","","","","","aclib::collections::unionfind::unionfind","","","","","","","","","","","aclib::cumsum","","aclib::cumsum::cumsum1d","","","","","","","","","","","","","aclib::cumsum::imos1d","","","","","","","","","","aclib::dic_order","","aclib::dic_order::bfs","aclib::dic_order::next_permutation","aclib::graph","","","aclib::graph::algo","","","","aclib::graph::algo::dijkstra","","aclib::graph::algo::dijkstra::one_to_many","","aclib::graph::algo::dijkstra::one_to_one","aclib::graph::algo::euler_tour","aclib::graph::with_petgraph","","","","aclib::graph::with_petgraph::diameter","aclib::graph::with_petgraph::grid","aclib::graph::without_petgraph","","","aclib::graph::without_petgraph::dijkstra","","","","","","","","","","","","","aclib::graph::without_petgraph::structure","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","aclib::graph::without_petgraph::structure::Weighted","aclib::integer","","","","","","","","","aclib::integer::counting","","","","","","","","","","","","","aclib::integer::devisors","","aclib::integer::gcd","","aclib::integer::modint","","","","","","","","","","","","","","","","","","","","","","","","","","aclib::integer::modulo","","","","aclib::integer::prime","","aclib::integer::rational","","","","","","","","","","","","","","","","","","","","","","","","","","","","","aclib::integer::sieve","","","","","","","","","","","","","","","aclib::integer::sort","","","","aclib::knapsack","","","aclib::knapsack::dp","","","","aclib::knapsack::meet_in_the_middle","aclib::knapsack::solver","aclib::macros",""],"d":["","","","","","","","","<strong>O(n)</strong>, max for one or more values","<strong>O(n)</strong>, average for values","<strong>O(n)</strong>, min for one or more values","<strong>O(n)</strong>, prod for values","<strong>O(n)</strong>, sum for values","","","","","","","","<strong>O(log(ans))</strong>, find the first index at which false -&gt; true …","<strong>O(log(n))</strong>, find the leftmost insertion index with key …","<strong>O(log(n))</strong>, find the leftmost insertion index with key …","<strong>O(log(n))</strong>, find the rightmost insertion index with key …","<strong>O(log(n))</strong>, find the rightmost insertion index with key …","<strong>O(log(ans/unit))</strong>, find the first index (width: <code>unit</code>) at …","<strong>O(log(end-start))</strong>, return (start, end) that f(end) == true …","<strong>O(log())</strong>, calculate log_a(x) by ceil (warning: overflow)","<strong>O(log())</strong>, calculate log_a(x) by floor (warning: overflow)","<strong>O(log(x))</strong>, calculate square root of x by ceil (warning: …","<strong>O(log(x))</strong>, calculate square root of x by floor (warning: …","<strong>O(log(|a|))</strong>, return the last index i such that a[i] &lt;= x","<strong>O(log(|a|))</strong>, return the first index i such that a[i] &gt;= x","<strong>O(log(|a|))</strong>, return the first index i such that a[i] &gt; x","<strong>O(n log(n))</strong>, return compressed vector","","","","<strong>O(n)</strong>, get hamming distance between a and b such as a.len() …","<strong>O(nm)</strong>, calculate edit distance between sequence a and …","<strong>O(n)</strong>, calculate chebyshev distance between two point of …","<strong>O(1)</strong>, calculate chebyshev distance between two point of …","<strong>O(n)</strong>, calculate manhattan distance between two point of …","<strong>O(1)</strong>, calculate manhattan distance between two point of …","<strong>O(n)</strong>, 45-degree rotation, manhattan distance become to be …","<strong>O(n log(n))</strong>, calculate inversion number, on data such as …","<strong>O(n log(n))</strong>, calculate inversion number for deduplicated …","<strong>O(n^2)</strong>, stable sorted by bubble sort","<strong>O(n log(n))</strong>, sorted by heap sort","<strong>O(n + inversion_number(data))</strong>, stable sorted by insertion …","<strong>O(n log(n))</strong>, stable sorted by merge sort","<strong>O(n log(n))</strong>, sorted data by quick sort","<strong>O(n^2)</strong>, stable sorted by selection sort","<strong>O(n)</strong>, get iterator of two pointer method. (if cond is true …","","","","","","","","","<strong>O(1)</strong>, count new element","<strong>O(1)</strong>, count the number of occurrences of elem","<strong>O(n)</strong>, count duplicate elements data","<strong>O(n log(usize::MAX))</strong>, get vec with sorted in descending …","<strong>O(n)</strong>, new empty counter","<strong>O(1)</strong>, remove element","","","","","","<strong>O(log(n))</strong>, heapify to leaf without recursive","<strong>O(n)</strong>, heapify in place (it is well known that bottom-up …","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, return the number of elements in this heap","<strong>O(1)</strong>, create min heap with operation that return total …","<strong>O(1)</strong>, peek min item","<strong>O(log(n))</strong>, pop min item","<strong>O(log(n))</strong>, push new item","","","","<strong>O(log(n))</strong>, heapify to root without recursive","","","","<strong>O(log(n))</strong>, heapify subtree","<strong>O(n)</strong>, heapify in place","Returns the argument unchanged.","<strong>O(n)</strong>, heapify","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, return the number of elements in this heap","<strong>O(1)</strong>, create min heap with operation that return total …","<strong>O(1)</strong>, peek min item","<strong>O(log(n))</strong>, pop min item","<strong>O(log(n))</strong>, push new item","","","","<strong>O(log(n))</strong>, heapify to root","","","<strong>O(1)</strong>, append the other linked list","","","<strong>O(1)</strong>, return and remove head item","<strong>O(n)</strong>, drop remain nodes","<strong>O(1)</strong>, add new item to the end of the list","<strong>O(n)</strong>, extends items as tails","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, return true if the list has no item, else return …","<strong>O(1)</strong>, return length of the list","<strong>O(1)</strong>, return empty linked list","<strong>O(1)</strong>, peek the top of the list","<strong>O(1)</strong>, peek the end of the list","<strong>O(1)</strong>, return and remove head item","<strong>O(1)</strong>, add new item to the top of the list","","","","","","","","","","","","<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …","","","wrap input to Monoid","Returns the argument unchanged.","identity element of Monoid","<strong>O(1)</strong>, range to leaf index half interval [left, right).","unwrap from monoid","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, return this segtree ’s number of data","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","binary operation that satisfy associative law for Monoid","<strong>O(log(n))</strong>, calculate f(range). (non-recursive)","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves","<strong>O(log(n))?</strong>, propagate lazy value to children","<strong>O(log^2(n))?</strong>, calculate half-open interval summation from …","<strong>O(log^2(n))?</strong>, calculate summation from root to leaf.","<strong>O(log^2(n))?</strong>, set lazy value from root to leaf","","","","<strong>O(log(n))</strong>, update the half interval [l, r) with add x.","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","Returns the argument unchanged.","<strong>O(n)</strong>, create segment tree, note that this method requires …","<strong>O(1)…?</strong>, this function seem to make size n temporary …","<strong>O(1)…?</strong>, this function seem to make size n temporary …","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update segment tree. (non-recursive)","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","Returns the argument unchanged.","<strong>O(1)…?</strong>, this function seem to make size n temporary …","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, either node x is root or not.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, get left child index of node x.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves.","<strong>O(1)</strong>, get parent index of node x.","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n)-log(node))</strong>, calculate from root to leaf.","<strong>O(log(i))</strong>, update from leaf to root.","<strong>O(1)</strong>, get right child index of node x.","<strong>O(1)</strong>, get root index.","","","","<strong>O(log(n))</strong>, update segment tree, leaf[k] = x.","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","","<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …","","","Returns the argument unchanged.","identity element of Monoid","<strong>O(1)</strong>, range to leaf index half interval [left, right).","unwrap monoid for return value","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, return this segtree ’s number of data","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","binary operation that satisfy associative law for Monoid","<strong>O(log(n))</strong>, calculate f(range). (non-recursive)","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","should use binary search tree","","","<strong>O(n + k log(k))</strong>, extend elements (size k)","Returns the argument unchanged.","<strong>O(n log(n))</strong>, make sorted list from iterator","<strong>O(size(index))</strong>, get the element(s) of at the index of the …","<strong>O(n)</strong>, insert element","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get iterator of vec","<strong>O(k)</strong>, max k elements","<strong>O(k)</strong>, min k elements","<strong>O(1)</strong>, get empty vec","","","","","","","<strong>O(m)</strong>, judge key is inserted or not","","Returns the argument unchanged.","<strong>O(m)</strong>, insert key","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, make empty trie tree","<strong>O(m)</strong>, remove key (WARNING: unimplemented!)","","","","","","","example of how to use petgraph::unionfind::Unionfind","","","","<strong>O(log(n))</strong>, find the root of x, and update the roots of …","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, create n trees with themselves as roots","<strong>O(log(n))</strong>, return members in same group (warning: returned …","<strong>O(log(n))</strong>, return number of members in same group","","","","<strong>O(log(n))</strong>, marge a’s trees and b’s tree, if already …","","","","<strong>O(n log(n))</strong>, get connected components (HashMap&lt;parent, …","<strong>O(log(n))</strong>, check does x and y belong same root","<strong>O(log(n))</strong>, find the root of x, and update the roots of …","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, create n trees with themselves as roots","<strong>O(log(n))</strong>, get root of x, this method is immutable","<strong>O(log(n))</strong>, return size of connected component","","","","<strong>O(log(n))</strong>, marge 2 trees with primary and standby roots, …","","","","<strong>worst: O(n)</strong>, find the root of x","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, create n trees with themselves as roots","","","","<strong>worst: O(n)</strong>, marge 2 trees with primary and standby roots","","","","","","Returns the argument unchanged.","<strong>O(n)</strong>, create n+1 size vec for cumsum from iterator","<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed iterator","<strong>O(1)</strong>, range to index half interval [left, right).","<strong>O(1)</strong>, calculate half-open interval summation r","Calls <code>U::from(self)</code>.","","","","<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed iterator","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, create n+1 size vec for imos 1d","<strong>O(1)</strong>, calculate sum of timing t","","","","","","<strong>O(|candidate| * (kinds of chars)^2)</strong>, generate the kth item …","<strong>O(n)</strong>, generate next item in dictionary order, in place","","","","","","","","","","<strong>O((n+m)log(n))</strong>, shortest paths cost, with dijkstra …","","<strong>O((n+m)log(n))</strong>, shortest path cost, with dijkstra algorithm","<strong>O(n+m)</strong>, get visited time and left time by dfs","example of how to use petgraph::Graph::from_edges","","","","<strong>O(n)</strong>, return diameter of given tree","<strong>O(hw)</strong>, make directed grid like graph from map (‘.’ is …","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","weighted/unweighted and directed/undirected graph structure","","","","","","<strong>O(1)</strong>, add node and return its index","<strong>O(n)</strong>, return breadth first search order","","","","","","","","","","","<strong>O(n)</strong>, return depth first search order","<strong>O((n+m)log(n))</strong>, shortest path distance and its route, with …","<strong>O((n+m)log(n))</strong>, shortest path number of hops and its …","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","<strong>O(1)</strong>, get weight of edge","<strong>O(1)</strong>, get node’s neighbors set","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get node’s neighbors set reference","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) to …","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) to …","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …","<strong>O(1)</strong>, number of nodes","<strong>O(1)</strong>, remove node and return its neighbors if possible  …","","","","","","","","","","","","","","","","<strong>O(1)</strong>, get weight of edge","","","","","","","","","","","","","","<strong>O(1)</strong>, compute nCk mod p","<strong>O(1)</strong>, compute nHk mod p","<strong>O(1)</strong>, compute n! mod p","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, ready to compute combination(n,k) mod p, where p is …","<strong>O(1)</strong>, compute nPk mod p","","","","<strong>O(sqrt(n))</strong>, calculate vec of devisors","<strong>O(sqrt(n))</strong>, calculate vec of pair os devisors","<strong>O(|v| log(min(v))</strong>, calculate gcd recursively","<strong>O(|v| log(min(v)))</strong>, calculate lcm recursively","","","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","<strong>O(log(min(a, b)))</strong>, calculate pair (gcd(a,b), x, y) such …","<strong>O(log(min(a, modulo)))</strong>, calculate inverse element of a in …","<strong>O(log(b))</strong>, calculate a^b % modulo","<strong>O(log(b))</strong>, calculate a^b % modulo","<strong>O(sqrt(n))</strong>, calculate prime factorization of n","<strong>O(n)…?</strong>, calculate vec of primes from 0 to max","","","","","","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","prime number is calculated as a index of Vec, so their …","","","<strong>O(log(n))</strong>, the number of integers that are prime to n each …","<strong>O(log(n))</strong>, calculate prime factorization of n, with …","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, if num is prime then return true, else return false","","<strong>O(n log(log(n)))</strong>, calculate size n+1 sieve, which vec[i] …","<strong>O(n)</strong>, calculate vec of primes from 0 to max","<strong>O(n)</strong>, returned vec[i] mean i is prime or not","","","","<strong>O(n + (max(data)-min(data)))</strong>, return stable sorted data.","<strong>O(n + (max(f(data))-min(f(data))))</strong>, return stable sorted …","<strong>O(n(log(max(data)))</strong>, return stable sorted data.","<strong>O(n(log(max(f(data))))</strong>, return stable sorted data.","","","","<strong>O(cn)</strong>, compute vec of products from table made by …","<strong>O(sum(v)n)</strong>, knapsack capacity is c, value of pi is v[i], …","<strong>O(sum(v)n)</strong>, solve knapsack with value-dp","<strong>O(cn)</strong>, knapsack capacity is c, value of pi is v[i], weight …","<strong>O(2^(n/2))</strong>, knapsack capacity is c, value of pi is v[i], …","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,5,5,5,6,5,6,5,6,5,5,5,5,6,5,5,5,5,5,5,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,0,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,0,0,11,11,11,11,12,11,12,11,11,11,11,12,11,11,11,11,11,11,0,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,0,14,14,14,14,14,14,14,14,14,14,14,14,0,0,0,0,0,15,15,15,15,15,15,15,15,15,15,15,15,0,16,16,16,16,16,16,16,16,16,16,16,16,16,16,0,17,17,17,17,17,17,17,17,17,17,0,0,0,18,18,18,18,18,18,18,18,18,18,18,18,0,19,19,19,19,19,19,19,19,19,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,20,20,20,20,20,20,20,20,20,20,20,0,0,0,0,21,0,22,22,23,24,25,21,22,23,24,25,21,22,22,22,22,23,24,25,21,22,22,22,23,24,25,21,22,22,22,22,22,22,22,22,23,24,25,21,22,23,24,25,21,22,23,24,25,21,22,22,26,0,0,0,0,0,0,0,0,0,0,27,27,27,27,27,27,27,27,27,27,27,27,0,0,0,0,0,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,0,0,0,0,0,0,0,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,0,30,30,30,30,30,30,30,30,30,30,30,30,30,30,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[],["option",4]],[[["partialord",8]],["usize",0]],[[],["usize",0]],[[["partialord",8]],["usize",0]],[[],["usize",0]],[[],["option",4]],[[["",0]]],[[]],[[]],[[["",26,[["clone",8],["partialord",8],["addassign",8],["subassign",8],["integer",8]]]],["",26,[["clone",8],["partialord",8],["addassign",8],["subassign",8],["integer",8]]]],[[["",26,[["clone",8],["partialord",8],["addassign",8],["subassign",8],["integer",8]]]],["",26,[["clone",8],["partialord",8],["addassign",8],["subassign",8],["integer",8]]]],[[["partialord",8]],["usize",0]],[[["partialord",8]],["usize",0]],[[["partialord",8]],["usize",0]],[[],["vec",3,[["usize",0]]]],null,null,null,[[["intoiterator",8],["intoiterator",8]],["usize",0]],[[],["usize",0]],[[],["",26,[["integer",8],["copy",8]]]],[[],["",26,[["integer",8],["copy",8]]]],[[],["",26,[["integer",8],["copy",8]]]],[[],["",26,[["integer",8],["copy",8]]]],[[],["vec",3]],[[],["usize",0]],[[],["usize",0]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["intoiter",3]],null,null,null,null,null,null,null,null,[[["",0]]],[[["",0]],["usize",0]],[[["intoiterator",8]]],[[["",0]],["vec",3]],[[]],[[["",0],["",0]]],null,null,null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["usize",0]]],[[["vec",3]]],[[]],[[]],[[["",0]],["usize",0]],[[]],[[["",0]],["option",4]],[[["",0]],["option",4]],[[["",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0]]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["usize",0]]],[[["vec",3]]],[[]],[[["",0]]],[[]],[[["",0]],["usize",0]],[[]],[[["",0]],["option",4]],[[["",0]],["option",4]],[[["",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0]]],null,null,[[["",0],["",0]]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["option",4]],[[["",0]]],[[["",0]]],[[["",0],["intoiterator",8]]],[[]],[[]],[[["",0]],["bool",0]],[[["",0]],["usize",0]],[[]],[[["",0]],["option",4,[["ref",3]]]],[[["",0]],["option",4,[["ref",3]]]],[[["",0]],["option",4]],[[["",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],null,null,null,null,null,null,null,null,[[["",0],["bool",0]],["option",4,[["usize",0]]]],[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[]],[[]],[[["",0]]],[[]],[[]],[[["",0]],["usize",0]],[[["",0]],["usize",0]],[[]],[[["",0],["",0]]],[[["",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0]]],[[["",0],["usize",0]]],null,null,[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[]],[[["",0]],["usize",0]],[[]],[[["",0]],["usize",0]],[[["",0],["usize",0]]],[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0],["usize",0],["usize",0],["usize",0],["usize",0]]],[[["",0],["usize",0],["usize",0],["usize",0],["usize",0],["usize",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0],["usize",0]]],null,[[["",0],["usize",0],["usize",0]],["option",4,[["usize",0]]]],[[["",0],["usize",0],["usize",0]],["option",4,[["usize",0]]]],[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[["vec",3]]],[[["",0]]],[[["",0]]],[[]],[[["",0]],["usize",0]],[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0],["usize",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0]]],[[["",0],["usize",0]]],[[["",0],["usize",0]]],null,[[["",0],["usize",0],["usize",0]],["option",4,[["usize",0]]]],[[["",0],["usize",0],["usize",0]],["option",4,[["usize",0]]]],[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[["",0]]],[[]],[[["",0]],["usize",0]],[[]],[[["",0]],["usize",0]],[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0],["usize",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0]]],[[["",0],["usize",0]]],null,[[["",0],["usize",0],["usize",0]],["option",4,[["usize",0]]]],[[["",0],["usize",0],["usize",0]],["option",4,[["usize",0]]]],[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[]],[[["usize",0]],["bool",0]],[[["",0]],["usize",0]],[[["usize",0]],["usize",0]],[[]],[[["",0]],["usize",0]],[[["usize",0]],["usize",0]],[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0],["usize",0],["usize",0],["usize",0],["usize",0]]],[[["",0],["usize",0]]],[[["usize",0]],["usize",0]],[[],["usize",0]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0]]],[[["",0],["usize",0]]],null,null,[[["",0],["bool",0]],["option",4,[["usize",0]]]],[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[]],[[["",0]]],[[]],[[]],[[["",0]],["usize",0]],[[["",0]],["usize",0]],[[]],[[["",0],["",0]]],[[["",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0]]],[[["",0],["usize",0]]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["intoiterator",8]]],[[]],[[["intoiterator",8]]],[[["",0]]],[[["",0]]],[[]],[[["",0]],["iter",3]],[[["",0],["usize",0]]],[[["",0],["usize",0]]],[[]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["bool",0]],[[["",0],["formatter",3]],["result",6]],[[]],[[["",0]],["bool",0]],[[]],[[]],[[["",0]],["bool",0]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],null,null,null,null,null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["usize",0]],["usize",0]],[[]],[[]],[[["usize",0]]],[[["",0],["usize",0]],["hashset",3]],[[["",0],["usize",0]],["usize",0]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0],["usize",0]],["bool",0]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["hashmap",3,[["usize",0],["vec",3,[["usize",0]]]]]],[[["",0],["usize",0],["usize",0]],["bool",0]],[[["",0],["usize",0]],["usize",0]],[[]],[[]],[[["usize",0]]],[[["",0],["usize",0]],["usize",0]],[[["",0],["usize",0]],["usize",0]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0],["usize",0]],["bool",0]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["usize",0]],["usize",0]],[[]],[[]],[[["usize",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0],["usize",0],["usize",0]],["usize",0]],null,null,null,[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[["intoiterator",8]]],[[["intoiterator",8]]],[[["",0],["rangebounds",8,[["usize",0]]]]],[[["",0],["rangebounds",8,[["usize",0]]]]],[[]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[]],[[["option",4,[["usize",0]]]]],[[["",0],["usize",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],null,null,[[["usize",0]],["vec",3]],[[],["bool",0]],null,null,null,null,null,null,[[["usize",0]],["hashmap",3,[["usize",0],["hashset",3,[["usize",0]]]]]],null,null,[[["hashmap",3]],["hashmap",3]],[[["hashmap",3]]],[[["hashmap",3]],["option",4]],[[["hashmap",3],["usize",0]]],null,null,null,null,[[["ungraph",6]],["usize",0]],[[]],null,null,null,null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["",0]],["ordering",4]],[[["",0],["minheaprecord",3]],["bool",0]],[[["",0],["",0]],["bool",0]],[[]],[[]],[[["",0],["minheaprecord",3]],["bool",0]],[[["",0],["",0]],["option",4,[["ordering",4]]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],null,null,null,null,null,null,[[["",0]],["usize",0]],[[["",0],["usize",0]],["vec",3,[["usize",0]]]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["usize",0]],["vec",3,[["usize",0]]]],[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0],["usize",0]]],[[]],[[]],[[]],[[]],[[]],[[["",0]]],[[["",0],["usize",0]]],[[]],[[]],[[]],[[]],[[]],[[["",0],["usize",0]],["hashset",3]],[[]],[[]],[[]],[[]],[[["",0]],["usize",0]],[[["",0],["usize",0]],["option",4,[["hashset",3,[["usize",0]]]]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0],["usize",0],["usize",0]]],null,null,null,null,null,null,null,null,null,null,null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0]]],[[]],[[]],[[["usize",0]]],[[["",0],["usize",0],["usize",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",26,[["integer",8],["toprimitive",8],["unsigned",8],["copy",8]]]],["vec",3,[["",26,[["integer",8],["toprimitive",8],["unsigned",8],["copy",8]]]]]],[[["",26,[["integer",8],["toprimitive",8],["unsigned",8],["copy",8]]]],["vec",3]],[[["vec",3]],["",26,[["integer",8],["copy",8]]]],[[["vec",3]],["",26,[["integer",8],["copy",8]]]],null,[[]],[[["",0]]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["modint",3]],[[["",0],["",0]]],[[["",0],["modint",3]],["ordering",4]],[[["",0],["modint",3]],["bool",0]],[[["",0],["",0]],["bool",0]],[[["",0],["formatter",3]],["result",6]],[[["",0],["formatter",3]],["result",6]],[[]],[[]],[[]],[[["",0]]],[[["",0],["modint",3]],["bool",0]],[[]],[[["",0],["modint",3]],["option",4,[["ordering",4]]]],[[]],[[["",0]]],[[["",0]]],[[["",0]],["string",3]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",26,[["integer",8],["signed",8],["copy",8]]],["",26,[["integer",8],["signed",8],["copy",8]]]]],[[["",26,[["integer",8],["signed",8],["copy",8]]],["",26,[["integer",8],["signed",8],["copy",8]]]],["option",4,[["",26,[["integer",8],["signed",8],["copy",8]]]]]],[[["",26,[["integer",8],["copy",8]]],["",26,[["integer",8],["copy",8]]],["",26,[["integer",8],["copy",8]]]],["",26,[["integer",8],["copy",8]]]],[[["u64",0],["u64",0],["u64",0]],["u64",0]],[[["u64",0]],["hashmap",3,[["u64",0],["usize",0]]]],[[["usize",0]],["vec",3,[["usize",0]]]],null,[[]],[[["",0]]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["rational",3]],[[["",0],["",0]]],[[["",0],["rational",3]],["ordering",4]],[[["",0],["",0]]],[[]],[[["",0]]],[[["",0],["",0]],["bool",0]],[[["",0],["",0]],["bool",0]],[[["",0],["formatter",3]],["result",6]],[[["",0],["formatter",3]],["result",6]],[[]],[[]],[[["",0]]],[[]],[[["",0]]],[[],["option",4]],[[["",0],["",0]],["option",4,[["ordering",4]]]],[[]],[[["",0]]],[[["",0]]],[[["",0]],["string",3]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0],["usize",0]],["usize",0]],[[["",0],["usize",0]],["hashmap",3,[["usize",0],["usize",0]]]],[[]],[[]],[[["",0],["usize",0]],["bool",0]],null,[[["usize",0]]],[[["",0]],["vec",3,[["usize",0]]]],[[["",0]],["vec",3,[["bool",0]]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[],["vec",3,[["",26,[["asprimitive",8,[["usize",0]]],["copy",8]]]]]],[[],["vec",3]],[[],["vec",3,[["",26,[["asprimitive",8,[["usize",0]]],["copy",8]]]]]],[[],["vec",3]],null,null,null,[[["usize",0],["usize",0]],["vec",3,[["usize",0]]]],[[["usize",0],["",26,[["integer",8],["copy",8]]]],["vec",3,[["vec",3,[["option",4,[["",26,[["integer",8],["copy",8]]]]]]]]]],[[["usize",0],["",26,[["integer",8],["copy",8]]]],["usize",0]],[[["usize",0],["usize",0]],["vec",3,[["vec",3,[["",26,[["integer",8],["copy",8]]]]]]]],[[["usize",0]]],[[["usize",0]]],null,null],"p":[[8,"Counter"],[3,"MinHeap"],[3,"BHeapSet"],[3,"LinkedList"],[3,"SegmentTree"],[8,"Monoid"],[3,"AddTree"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"SegmentTree"],[8,"Monoid"],[3,"SortedVec"],[3,"TrieTree"],[3,"MergeTechnique"],[3,"UnionFind"],[3,"UnionFind"],[3,"CumSum"],[3,"Imos1D"],[3,"MinHeapRecord"],[4,"Weighted"],[3,"AdjacencyList"],[4,"Undirected"],[4,"Directed"],[4,"Unweighted"],[13,"Weight"],[3,"Counting"],[3,"ModInt"],[3,"Rational"],[3,"SieveOfEratosthenes"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};