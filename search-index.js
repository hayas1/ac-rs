var searchIndex = JSON.parse('{\
"aclib":{"doc":"Rust practice: Data structure and Algorithms","t":[0,0,0,0,0,0,0,14,14,14,14,14,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,8,10,10,10,0,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,0,0,0,0,0,8,3,11,11,11,10,11,10,11,10,11,11,11,11,10,11,11,11,11,11,11,0,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,8,3,11,11,11,11,10,11,10,11,11,11,11,10,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,0,0,0,0,0,5,5,5,0,0,0,0,5,5,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,3,4,4,4,13,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,0,0,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,5,5,3,11,11,11,5,11,5,11,11,11,12,11,11,11,11,11,11,5,5,5,5,0,0,0,5,5,5,5,5,5,0,0],"n":["algo","collections","cumsum","graph","integer","knapsack","macros","max","mean","min","prod","sum","bisect","compress","distance","inversion","sort","bisect","bisect_left","bisect_left_by_key","bisect_right","bisect_right_by_key","bisect_unit","initial_indices","log_ceil","log_floor","sqrt_ceil","sqrt_floor","coordinate_compress","hamming","levenshtein","manhattan_chebyshev","hamming_distance","levenshtein_distance","chebyshev_distance","chebyshev_distance_2d","manhattan_distance","manhattan_distance_2d","rotate_45","inversion_number","inversion_number_with","bubble_sort","heap_sort","insertion_sort","merge_sort","quick_sort","selection_sort","counter","linkedlist","segtree","sorted_vec","trie_tree","unionfind","Counter","count","most_common","new","singly","LinkedList","append","borrow","borrow_mut","dequeue","drop","enqueue","extend","from","into","is_empty","len","new","peek_head","peek_tail","pop","push","try_from","try_into","type_id","custom_tree","lazy_segtree","non_copy","non_recursive","recursive","segtree","Monoid","SegmentTree","bisect","borrow","borrow_mut","from","from","identity","indices","into","into","leaf_offset","len","new","operation","query","try_from","try_into","type_id","update","update_with","addtree","AddTree","borrow","borrow_mut","from","into","leaf_offset","new","num_of_leaf","propagation","query","recursive_query","recursive_update_range","try_from","try_into","type_id","update_range","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","from","index","index_mut","into","leaf_offset","query","swap","try_from","try_into","type_id","update","update_parents","update_with","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","index","into","leaf_offset","new","num_of_leaf","query","swap","try_from","try_into","type_id","update","update_with","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","into","is_root","leaf_offset","left_child","new","num_of_leaf","parent","query","recursive_query","recursive_update","right_child","root","try_from","try_into","type_id","update","update_with","Monoid","SegmentTree","bisect","borrow","borrow_mut","from","identity","indices","into","into","leaf_offset","len","new","operation","query","try_from","try_into","type_id","update","update_with","SortedVec","borrow","borrow_mut","extend","from","from_iter","index","insert","into","iter","max_elements","min_elements","new","try_from","try_into","type_id","TrieTree","borrow","borrow_mut","contains","fmt","from","insert","into","new","remove","try_from","try_into","type_id","smooth_unionfind","unionfind","with_petgraph","UnionFind","borrow","borrow_mut","equiv","find","from","into","new","try_from","try_into","type_id","union","UnionFind","borrow","borrow_mut","find","from","into","new","try_from","try_into","type_id","union","cumsum1d","imos1d","CumSum","borrow","borrow_mut","from","from_iter","from_iter","indices","interval_sum","into","try_from","try_into","type_id","with_data","Imos1D","borrow","borrow_mut","from","into","new","sum_timing","try_from","try_into","type_id","dijkstra","with_petgraph","without_petgraph","one_to_many","one_to_one","dijkstra","from_to_indices","dijkstra","arbitrary","diameter","grid","search","diameter_of_tree","field_to_directed_grid","dijkstra","search","structure","MinHeapRecord","borrow","borrow_mut","cmp","eq","equivalent","from","into","ne","partial_cmp","try_from","try_into","type_id","AdjacencyList","Directed","Undirected","Unweighted","Weight","Weighted","add_node","bfs","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","dfs","dijkstra","dijkstra","from","from","from","from","from","index","index","into","into","into","into","into","neighbors","new_unweighted_directed","new_unweighted_undirected","new_weighted_directed","new_weighted_undirected","nodes_len","remove_node","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","weight","counting","devisors","gcd","modulo","prime","sort","Counting","borrow","borrow_mut","combination","combination_with_repetition","factorial","from","into","new","permutation","try_from","try_into","type_id","devisors","devisors_pair","gcd_recursive","lcm_recursive","ex_euclid","inverse_mod_mul","mod_pow","mod_pow_u64","SieveOfEratosthenes","borrow","borrow_mut","euler_phi","factorization","factorization","fast_primes","from","into","is_prime","min_primes","new","primes","sieve","try_from","try_into","type_id","counting_sorted","counting_sorted_with","radix_sorted","radix_sorted_with","dp","meet_in_the_middle","solver","dp_weight_with_backtrack","knapsack_dp_value","knapsack_dp_value_solve","knapsack_dp_weight","knapsack_half_enumerate","knapsack","compare","summation"],"q":["aclib","","","","","","","","","","","","aclib::algo","","","","","aclib::algo::bisect","","","","","","","","","","","aclib::algo::compress","aclib::algo::distance","","","aclib::algo::distance::hamming","aclib::algo::distance::levenshtein","aclib::algo::distance::manhattan_chebyshev","","","","","aclib::algo::inversion","","aclib::algo::sort","","","","","","aclib::collections","","","","","","aclib::collections::counter","","","","aclib::collections::linkedlist","aclib::collections::linkedlist::singly","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree","","","","","","aclib::collections::segtree::custom_tree","","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::lazy_segtree","aclib::collections::segtree::lazy_segtree::addtree","","","","","","","","","","","","","","","","aclib::collections::segtree::non_copy","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::non_recursive","","","","","","","","","","","","","","","","","","aclib::collections::segtree::recursive","","","","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::segtree","","","","","","","","","","","","","","","","","","","","aclib::collections::sorted_vec","","","","","","","","","","","","","","","","aclib::collections::trie_tree","","","","","","","","","","","","","aclib::collections::unionfind","","","aclib::collections::unionfind::smooth_unionfind","","","","","","","","","","","","aclib::collections::unionfind::unionfind","","","","","","","","","","","aclib::cumsum","","aclib::cumsum::cumsum1d","","","","","","","","","","","","","aclib::cumsum::imos1d","","","","","","","","","","aclib::graph","","","aclib::graph::dijkstra","","aclib::graph::dijkstra::one_to_many","","aclib::graph::dijkstra::one_to_one","aclib::graph::with_petgraph","","","","aclib::graph::with_petgraph::diameter","aclib::graph::with_petgraph::grid","aclib::graph::without_petgraph","","","aclib::graph::without_petgraph::dijkstra","","","","","","","","","","","","","aclib::graph::without_petgraph::structure","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","aclib::integer","","","","","","aclib::integer::counting","","","","","","","","","","","","","aclib::integer::devisors","","aclib::integer::gcd","","aclib::integer::modulo","","","","aclib::integer::prime","","","","","","","","","","","","","","","","","aclib::integer::sort","","","","aclib::knapsack","","","aclib::knapsack::dp","","","","aclib::knapsack::meet_in_the_middle","aclib::knapsack::solver","aclib::macros",""],"d":["","","","","","","","<strong>O(n)</strong>, max for one or more values","<strong>O(n)</strong>, average for values","<strong>O(n)</strong>, min for one or more values","<strong>O(n)</strong>, prod for values","<strong>O(n)</strong>, sum for values","","","","","","<strong>O(log(ans))</strong>, find the first index at which false -> true …","<strong>O(log(n))</strong>, find the leftmost insertion index with key …","<strong>O(log(n))</strong>, find the leftmost insertion index with key …","<strong>O(log(n))</strong>, find the rightmost insertion index with key …","<strong>O(log(n))</strong>, find the rightmost insertion index with key …","<strong>O(log(ans/unit))</strong>, find the first index (width: <code>unit</code>) at …","<strong>O(log(end-start))</strong>, return (start, end) that f(end) == …","<strong>O(log())</strong>, calculate log_a(x) by ceil (warning: overflow)","<strong>O(log())</strong>, calculate log_a(x) by floor (warning: overflow)","<strong>O(log(x))</strong>, calculate square root of x by ceil (warning: …","<strong>O(log(x))</strong>, calculate square root of x by floor (warning: …","<strong>O(n log(n))</strong>, return compressed vector","","","","<strong>O(n)</strong>, get hamming distance between a and b such as …","<strong>O(nm)</strong>, calculate edit distance between sequence a and …","<strong>O(n)</strong>, calculate chebyshev distance between two point of …","<strong>O(1)</strong>, calculate chebyshev distance between two point of …","<strong>O(n)</strong>, calculate manhattan distance between two point of …","<strong>O(1)</strong>, calculate manhattan distance between two point of …","<strong>O(n)</strong>, 45-degree rotation, manhattan distance become to be …","<strong>O(n log(n))</strong>, calculate inversion number, on data such as …","<strong>O(n log(n))</strong>, calculate inversion number for deduplicated …","<strong>O(n^2)</strong>, stable sorted by bubble sort","<strong>O(n log(n))</strong>, sorted by heap sort","<strong>O(n + inversion_number(data))</strong>, stable sorted by insertion …","<strong>O(n log(n))</strong>, stable sorted by merge sort","<strong>O(n log(n))</strong>, sorted data by quick sort","<strong>O(n^2)</strong>, stable sorted by selection sort","","","","","","","","","","","","","<strong>O(1)</strong>, append the other linked list","","","<strong>O(1)</strong>, return and remove head item","<strong>O(n)</strong>, drop remain nodes","<strong>O(1)</strong>, add new item to the end of the list","<strong>O(n)</strong>, extends items as tails","","","<strong>O(1)</strong>, return true if the list has no item, else return …","<strong>O(1)</strong>, return length of the list","<strong>O(1)</strong>, return empty linked list","<strong>O(1)</strong>, peek the top of the list","<strong>O(1)</strong>, peek the end of the list","<strong>O(1)</strong>, return and remove head item","<strong>O(1)</strong>, add new item to the top of the list","","","","","","","","","","","","<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …","","","wrap input to Monoid","","identity element of Monoid","<strong>O(1)</strong>, range to leaf index half interval [left, right).","unwrap from monoid","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, return this segtree ’s number of data","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","binary operation that satisfy associative law for Monoid","<strong>O(log(n))</strong>, calculate f(range). (non-recursive)","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","","","","","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves","<strong>O(log(n))?</strong>, propagate lazy value to children","<strong>O(log^2(n))?</strong>, calculate half-open interval summation from …","<strong>O(log^2(n))?</strong>, calculate summation from root to leaf.","<strong>O(log^2(n))?</strong>, set lazy value from root to leaf","","","","<strong>O(log(n))</strong>, update the half interval [l, r) with add x.","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","","<strong>O(n)</strong>, create segment tree, note that this method requires …","<strong>O(1)…?</strong>, this function seem to make size n temporary …","<strong>O(1)…?</strong>, this function seem to make size n temporary …","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update segment tree. (non-recursive)","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","","<strong>O(1)…?</strong>, this function seem to make size n temporary …","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","","","<strong>O(1)</strong>, either node x is root or not.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, get left child index of node x.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves.","<strong>O(1)</strong>, get parent index of node x.","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n)-log(node))</strong>, calculate from root to leaf.","<strong>O(log(i))</strong>, update from leaf to root.","<strong>O(1)</strong>, get right child index of node x.","<strong>O(1)</strong>, get root index.","","","","<strong>O(log(n))</strong>, update segment tree, leaf[k] = x.","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","","<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …","","","","identity element of Monoid","<strong>O(1)</strong>, range to leaf index half interval [left, right).","unwrap monoid for return value","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, return this segtree ’s number of data","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","binary operation that satisfy associative law for Monoid","<strong>O(log(n))</strong>, calculate f(range). (non-recursive)","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","should use binary search tree","","","<strong>O(n + k log(k))</strong>, extend elements (size k)","","<strong>O(n log(n))</strong>, make sorted list from iterator","<strong>O(size(index))</strong>, get the element(s) of at the index of the …","<strong>O(n)</strong>, insert element","","<strong>O(1)</strong>, get iterator of vec","<strong>O(k)</strong>, max k elements","<strong>O(k)</strong>, min k elements","<strong>O(1)</strong>, get empty vec","","","","","","","<strong>O(m)</strong>, judge key is inserted or not","","","<strong>O(m)</strong>, insert key","","<strong>O(1)</strong>, make empty trie tree","<strong>O(m)</strong>, remove key (WARNING: unimplemented!)","","","","","","example of how to use petgraph::unionfind::Unionfind","","","","<strong>O(log(n))</strong>, check does x and y belong same root","<strong>O(log(n))</strong>, find the root of x, and update the roots of …","","","<strong>O(n)</strong>, create n trees with themselves as roots","","","","<strong>O(log(n))</strong>, marge 2 trees with primary and standby roots","","","","<strong>worst: O(n)</strong>, find the root of x","","","<strong>O(n)</strong>, create n trees with themselves as roots","","","","<strong>worst: O(n)</strong>, marge 2 trees with primary and standby roots","","","","","","","<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed …","<strong>O(n)</strong>, create n+1 size vec for cumsum from iterator","<strong>O(1)</strong>, range to index half interval [left, right).","<strong>O(1)</strong>, calculate half-open interval summation r","","","","","<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed …","","","","","","<strong>O(n)</strong>, create n+1 size vec for imos 1d","<strong>O(1)</strong>, calculate sum of timing t","","","","","","","","","<strong>O((n+m)log(n))</strong>, shortest paths cost, with dijkstra …","","<strong>O((n+m)log(n))</strong>, shortest path cost, with dijkstra …","example of how to use petgraph::Graph::from_edges","","","","<strong>O(n)</strong>, return diameter of given tree","<strong>O(hw)</strong>, make directed grid like graph from map (‘.’ is …","","","","","","","","","","","","","","","","","weighted/unweighted and directed/undirected graph …","","","","","","<strong>O(1)</strong>, add node and return its index","<strong>O(n)</strong>, return breadth first search order","","","","","","","","","","","<strong>O(n)</strong>, return depth first search order","<strong>O((n+m)log(n))</strong>, shortest path number of hops and its …","<strong>O((n+m)log(n))</strong>, shortest path distance and its route, …","","","","","","<strong>O(1)</strong>, get weight of edge","<strong>O(1)</strong>, get node’s neighbors set","","","","","","<strong>O(1)</strong>, get node’s neighbors set reference","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) …","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) …","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …","<strong>O(1)</strong>, number of nodes","<strong>O(1)</strong>, remove node and return its neighbors if possible  <strong>…","","","","","","","","","","","","","","","","<strong>O(1)</strong>, get weight of edge","","","","","","","","","","<strong>O(1)</strong>, compute nCk mod p","<strong>O(1)</strong>, compute nHk mod p","<strong>O(1)</strong>, compute n! mod p","","","<strong>O(n)</strong>, ready to compute combination(n,k) mod p, where p is …","<strong>O(1)</strong>, compute nPk mod p","","","","<strong>O(sqrt(n))</strong>, calculate vec of devisors","<strong>O(sqrt(n))</strong>, calculate vec of pair os devisors","<strong>O(|v| log(min(v))</strong>, calculate gcd recursively","<strong>O(|v| log(min(v)))</strong>, calculate lcm recursively","<strong>O(log(min(a, b)))</strong>, calculate pair (gcd(a,b), x, y) such …","<strong>O(log(min(a, modulo)))</strong>, calculate inverse element of a in …","<strong>O(log(b))</strong>, calculate a^b % modulo","<strong>O(log(b))</strong>, calculate a^b % modulo","","","","<strong>O(log(n))</strong>, the number of integers that are prime to n …","<strong>O(sqrt(n))</strong>, calculate prime factorization of n","<strong>O(log(n))</strong>, calculate prime factorization of n, with …","<strong>O(n)…?</strong>, calculate vec of primes from 0 to max","","","<strong>O(1)</strong>, if num is prime then return true, else return false","","<strong>O(n log(log(n)))</strong>, calculate n+1 size sieve, which vec[i] …","<strong>O(n)</strong>, calculate vec of primes from 0 to max","<strong>O(n)</strong>, calculate n+1 size vec, which vec[i] mean i is …","","","","<strong>O(n + (max(data)-min(data)))</strong>, return stable sorted data.","<strong>O(n + (max(f(data))-min(f(data))))</strong>, return stable sorted …","<strong>O(n(log(max(data)))</strong>, return stable sorted data.","<strong>O(n(log(max(f(data))))</strong>, return stable sorted data.","","","","<strong>O(cn)</strong>, compute vec of products from table made by …","<strong>O(sum(v)n)</strong>, knapsack capacity is c, value of pi is v[i], …","<strong>O(sum(v)n)</strong>, solve knapsack with value-dp","<strong>O(cn)</strong>, knapsack capacity is c, value of pi is v[i], …","<strong>O(2^(n/2))</strong>, knapsack capacity is c, value of pi is v[i], …","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,3,3,3,4,3,4,3,4,3,3,3,3,4,3,3,3,3,3,3,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,9,9,9,9,10,9,10,9,9,9,9,10,9,9,9,9,9,9,0,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,12,12,12,12,12,12,12,12,12,12,12,12,0,0,0,0,13,13,13,13,13,13,13,13,13,13,13,0,14,14,14,14,14,14,14,14,14,14,0,0,0,15,15,15,15,15,15,15,15,15,15,15,15,0,16,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,17,17,17,17,17,17,17,17,17,17,17,0,0,0,0,18,0,19,19,20,21,22,18,19,20,21,22,18,19,19,19,19,20,21,22,18,19,19,19,20,21,22,18,19,19,19,19,19,19,19,19,20,21,22,18,19,20,21,22,18,19,20,21,22,18,19,19,0,0,0,0,0,0,0,23,23,23,23,23,23,23,23,23,23,23,23,0,0,0,0,0,0,0,0,0,24,24,24,0,24,0,24,24,24,24,24,24,24,24,24,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[],["option",4]],[[["partialord",8]],["usize",15]],[[],["usize",15]],[[["partialord",8]],["usize",15]],[[],["usize",15]],[[],["option",4]],[[]],[[]],[[]],[[["partialord",8],["subassign",8],["integer",8],["clone",8],["addassign",8]],[["partialord",8],["subassign",8],["integer",8],["clone",8],["addassign",8]]],[[["partialord",8],["subassign",8],["integer",8],["clone",8],["addassign",8]],[["partialord",8],["subassign",8],["integer",8],["clone",8],["addassign",8]]],[[],[["vec",3],["usize",15]]],null,null,null,[[["intoiterator",8]],["usize",15]],[[],["usize",15]],[[],[["copy",8],["integer",8]]],[[],[["copy",8],["integer",8]]],[[],[["copy",8],["integer",8]]],[[],[["copy",8],["integer",8]]],[[],["vec",3]],[[],["usize",15]],[[],["usize",15]],[[]],[[]],[[]],[[]],[[]],[[]],null,null,null,null,null,null,null,[[],["usize",15]],[[],["vec",3]],[[["iterator",8]]],null,null,[[]],[[]],[[]],[[],["option",4]],[[]],[[]],[[["intoiterator",8]]],[[]],[[]],[[],["bool",15]],[[],["usize",15]],[[]],[[],[["ref",3],["option",4]]],[[],[["ref",3],["option",4]]],[[],["option",4]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,null,[[["bool",15]],[["option",4],["usize",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[],["usize",15]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["usize",15]]],[[["usize",15]]],null,null,[[]],[[]],[[]],[[]],[[],["usize",15]],[[]],[[],["usize",15]],[[["usize",15]]],[[["usize",15]]],[[["usize",15]]],[[["usize",15]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["usize",15]]],null,[[["usize",15]],[["option",4],["usize",15]]],[[["usize",15]],[["option",4],["usize",15]]],[[]],[[]],[[]],[[["vec",3]]],[[]],[[]],[[]],[[],["usize",15]],[[["usize",15]]],[[["usize",15]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["usize",15]]],[[["usize",15]]],[[["usize",15]]],null,[[["usize",15]],[["option",4],["usize",15]]],[[["usize",15]],[["option",4],["usize",15]]],[[]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[]],[[],["usize",15]],[[["usize",15]]],[[["usize",15]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["usize",15]]],[[["usize",15]]],null,[[["usize",15]],[["option",4],["usize",15]]],[[["usize",15]],[["option",4],["usize",15]]],[[]],[[]],[[]],[[]],[[["usize",15]],["bool",15]],[[],["usize",15]],[[["usize",15]],["usize",15]],[[]],[[],["usize",15]],[[["usize",15]],["usize",15]],[[["usize",15]]],[[["usize",15]]],[[["usize",15]]],[[["usize",15]],["usize",15]],[[],["usize",15]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["usize",15]]],[[["usize",15]]],null,null,[[["bool",15]],[["option",4],["usize",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[],["usize",15]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["usize",15]]],[[["usize",15]]],null,[[]],[[]],[[["intoiterator",8]]],[[]],[[["intoiterator",8]]],[[]],[[]],[[]],[[],["iter",3]],[[["usize",15]]],[[["usize",15]]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,[[]],[[]],[[],["bool",15]],[[["formatter",3]],["result",6]],[[]],[[],["bool",15]],[[]],[[]],[[],["bool",15]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,[[]],[[]],[[["usize",15]],["bool",15]],[[["usize",15]],["usize",15]],[[]],[[]],[[["usize",15]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["usize",15]],["bool",15]],null,[[]],[[]],[[["usize",15]],["usize",15]],[[]],[[]],[[["usize",15]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["usize",15]],["usize",15]],null,null,null,[[]],[[]],[[]],[[["intoiterator",8]]],[[["intoiterator",8]]],[[["usize",15],["rangebounds",8]]],[[["usize",15],["rangebounds",8]]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[]],null,[[]],[[]],[[]],[[]],[[["option",4],["usize",15]]],[[["usize",15]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,[[["hashmap",3]],["hashmap",3]],[[["hashmap",3]]],[[["hashmap",3]],["option",4]],null,null,null,null,[[["ungraph",6]],["usize",15]],[[]],null,null,null,null,[[]],[[]],[[],["ordering",4]],[[["minheaprecord",3]],["bool",15]],[[],["bool",15]],[[]],[[]],[[["minheaprecord",3]],["bool",15]],[[],[["option",4],["ordering",4]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,[[],["usize",15]],[[["usize",15]],[["vec",3],["usize",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["usize",15]],[["vec",3],["usize",15]]],[[["usize",15]]],[[["usize",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[["usize",15]]],[[]],[[]],[[]],[[]],[[]],[[["usize",15]],["hashset",3]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[["usize",15]],[["hashset",3],["option",4]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[["usize",15]]],null,null,null,null,null,null,null,[[]],[[]],[[["usize",15]]],[[["usize",15]]],[[["usize",15]]],[[]],[[]],[[["usize",15]]],[[["usize",15]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["toprimitive",8],["unsigned",8],["integer",8],["copy",8]],[["vec",3],["copy",8],["integer",8],["unsigned",8],["toprimitive",8]]],[[["toprimitive",8],["unsigned",8],["integer",8],["copy",8]],["vec",3]],[[["vec",3]],[["copy",8],["integer",8]]],[[["vec",3]],[["copy",8],["integer",8]]],[[["signed",8],["integer",8],["copy",8]]],[[["signed",8],["integer",8],["copy",8]],[["signed",8],["option",4],["integer",8],["copy",8]]],[[["integer",8],["copy",8]],[["copy",8],["integer",8]]],[[["u64",15]],["u64",15]],null,[[]],[[]],[[["usize",15]],["usize",15]],[[["usize",15]],[["usize",15],["hashmap",3]]],[[["usize",15]],[["usize",15],["hashmap",3]]],[[["usize",15]],[["vec",3],["usize",15]]],[[]],[[]],[[["usize",15]],["bool",15]],null,[[["usize",15]]],[[],[["vec",3],["usize",15]]],[[],[["vec",3],["bool",15]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],[["vec",3],["copy",8],["integer",8],["usize",15],["asprimitive",8]]],[[],["vec",3]],[[],[["vec",3],["copy",8],["integer",8],["usize",15],["asprimitive",8]]],[[],["vec",3]],null,null,null,[[["usize",15]],[["vec",3],["usize",15]]],[[["integer",8],["usize",15],["copy",8]],[["vec",3],["vec",3]]],[[["integer",8],["usize",15],["copy",8]],["usize",15]],[[["usize",15]],[["vec",3],["vec",3]]],[[["usize",15]]],[[["usize",15]]],null,null],"p":[[8,"Counter"],[3,"LinkedList"],[3,"SegmentTree"],[8,"Monoid"],[3,"AddTree"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"SegmentTree"],[8,"Monoid"],[3,"SortedVec"],[3,"TrieTree"],[3,"UnionFind"],[3,"UnionFind"],[3,"CumSum"],[3,"Imos1D"],[3,"MinHeapRecord"],[4,"Weighted"],[3,"AdjacencyList"],[4,"Undirected"],[4,"Directed"],[4,"Unweighted"],[3,"Counting"],[3,"SieveOfEratosthenes"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};