var searchIndex = JSON.parse('{\
"aclib":{"doc":"Rust practice: Data structure and AlgorithmsThe goal is …","i":[[0,"algo","aclib","",null,null],[0,"bisect","aclib::algo","",null,null],[5,"initial_indices","aclib::algo::bisect","<strong>O(log(end-start))</strong>, return (start, end) that f(end) == …",null,[[]]],[5,"bisect","","<strong>O(log(ans))</strong>, find the first index at which false -> true …",null,[[],["option",4]]],[5,"bisect_left_by_key","","<strong>O(log(n))</strong>, find the leftmost insertion index with key …",null,[[]]],[5,"bisect_left","","<strong>O(log(n))</strong>, find the leftmost insertion index with key …",null,[[["partialord",8]]]],[5,"bisect_right_by_key","","<strong>O(log(n))</strong>, find the rightmost insertion index with key …",null,[[]]],[5,"bisect_right","","<strong>O(log(n))</strong>, find the rightmost insertion index with key …",null,[[["partialord",8]]]],[0,"distance","aclib::algo","",null,null],[0,"levenshtein","aclib::algo::distance","",null,null],[5,"levenshtein_distance","aclib::algo::distance::levenshtein","<strong>O(nm)</strong>, calculate edit distance between sequence a and …",null,[[]]],[0,"manhattan_chebyshev","aclib::algo::distance","",null,null],[5,"manhattan_distance_2d","aclib::algo::distance::manhattan_chebyshev","<strong>O(1)</strong>, calculate manhattan distance between two point of …",null,[[],[["copy",8],["integer",8]]]],[5,"rotate_45","","<strong>O(n)</strong>, 45-degree rotation, manhattan distance become to be …",null,[[],["vec",3]]],[5,"chebyshev_distance_2d","","<strong>O(1)</strong>, calculate chebyshev distance between two point of …",null,[[],[["copy",8],["integer",8]]]],[5,"manhattan_distance","","<strong>O(n)</strong>, calculate manhattan distance between two point of …",null,[[],[["copy",8],["integer",8]]]],[5,"chebyshev_distance","","<strong>O(n)</strong>, calculate chebyshev distance between two point of …",null,[[],[["copy",8],["integer",8]]]],[0,"inversion","aclib::algo","",null,null],[5,"inversion_number","aclib::algo::inversion","<strong>O(n log(n))</strong>, calculate inversion number, on data such as …",null,[[]]],[5,"inversion_number_with","","<strong>O(n log(n))</strong>, calculate inversion number for deduplicated …",null,[[]]],[0,"sort","aclib::algo","",null,null],[5,"bubble_sort","aclib::algo::sort","<strong>O(n^2)</strong>, stable sorted by bubble sort",null,[[]]],[5,"selection_sort","","<strong>O(n^2)</strong>, stable sorted by selection sort",null,[[]]],[5,"insertion_sort","","<strong>O(n + inversion_number(data))</strong>, stable sorted by insertion …",null,[[]]],[5,"heap_sort","","<strong>O(n log(n))</strong>, sorted by heap sort",null,[[]]],[5,"merge_sort","","<strong>O(n log(n))</strong>, stable sorted by merge sort",null,[[]]],[5,"quick_sort","","<strong>O(n log(n))</strong>, sorted data by quick sort",null,[[]]],[0,"collections","aclib","",null,null],[0,"counter","aclib::collections","",null,null],[8,"Counter","aclib::collections::counter","",null,null],[10,"new","","",0,[[["iterator",8]]]],[10,"count","","",0,[[]]],[10,"most_common","","",0,[[],["vec",3]]],[0,"linkedlist","aclib::collections","",null,null],[0,"singly","aclib::collections::linkedlist","",null,null],[3,"LinkedList","aclib::collections::linkedlist::singly","",null,null],[11,"new","","<strong>O(1)</strong>, return empty linked list",1,[[]]],[11,"len","","<strong>O(1)</strong>, return length of the list",1,[[]]],[11,"is_empty","","<strong>O(1)</strong>, return true if the list has no item, else return …",1,[[]]],[11,"peek_head","","<strong>O(1)</strong>, peek the top of the list",1,[[],[["option",4],["ref",3]]]],[11,"peek_tail","","<strong>O(1)</strong>, peek the end of the list",1,[[],[["option",4],["ref",3]]]],[11,"push","","<strong>O(1)</strong>, add new item to the top of the list",1,[[]]],[11,"pop","","<strong>O(1)</strong>, return and remove head item",1,[[],["option",4]]],[11,"enqueue","","<strong>O(1)</strong>, add new item to the end of the list",1,[[]]],[11,"dequeue","","<strong>O(1)</strong>, return and remove head item",1,[[],["option",4]]],[11,"append","","<strong>O(1)</strong>, append the other linked list",1,[[]]],[0,"segtree","aclib::collections","",null,null],[0,"lazy_segtree","aclib::collections::segtree","",null,null],[0,"addtree","aclib::collections::segtree::lazy_segtree","",null,null],[3,"AddTree","aclib::collections::segtree::lazy_segtree::addtree","",null,null],[11,"new","","<strong>O(n)</strong>, create segment tree. (e is identity element for a …",2,[[]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",2,[[]]],[11,"num_of_leaf","","<strong>O(1)</strong>, get size of leaves",2,[[]]],[11,"update_range","","<strong>O(log(n))</strong>, update the half interval [l, r) with add x.",2,[[]]],[11,"recursive_update_range","","<strong>O(log^2(n))?</strong>, set lazy value from root to leaf",2,[[]]],[11,"query","","<strong>O(log^2(n))?</strong>, calculate half-open interval summation from …",2,[[]]],[11,"recursive_query","","<strong>O(log^2(n))?</strong>, calculate summation from root to leaf.",2,[[]]],[11,"propagation","","<strong>O(log(n))?</strong>, propagate lazy value to children",2,[[]]],[0,"non_copy","aclib::collections::segtree","",null,null],[3,"SegmentTree","aclib::collections::segtree::non_copy","",null,null],[11,"from","","<strong>O(n)</strong>, create segment tree, note that this method requires …",3,[[["vec",3]]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",3,[[]]],[11,"update","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …",3,[[]]],[11,"update_with","","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …",3,[[]]],[11,"swap","","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …",3,[[]]],[11,"update_parents","","<strong>O(log(n))</strong>, update segment tree. (non-recursive)",3,[[]]],[11,"query","","<strong>O(log(n))</strong>, calculate f(l, l+1, ..., r-1). note the half …",3,[[]]],[11,"bisect_left","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …",3,[[],["option",4]]],[11,"bisect_right","","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …",3,[[],["option",4]]],[0,"non_recursive","aclib::collections::segtree","",null,null],[3,"SegmentTree","aclib::collections::segtree::non_recursive","",null,null],[11,"new","","<strong>O(n)</strong>, create segment tree. (e is identity element for a …",4,[[]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",4,[[]]],[11,"num_of_leaf","","<strong>O(1)</strong>, get size of leaves",4,[[]]],[11,"update","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …",4,[[]]],[11,"update_with","","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …",4,[[]]],[11,"swap","","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …",4,[[]]],[11,"query","","<strong>O(log(n))</strong>, calculate f(l, l+1, ..., r-1). note the half …",4,[[]]],[11,"bisect_left","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …",4,[[],["option",4]]],[11,"bisect_right","","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …",4,[[],["option",4]]],[0,"recursive","aclib::collections::segtree","",null,null],[3,"SegmentTree","aclib::collections::segtree::recursive","",null,null],[11,"new","","<strong>O(n)</strong>, create segment tree. (e is identity element for a …",5,[[]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",5,[[]]],[11,"num_of_leaf","","<strong>O(1)</strong>, get size of leaves.",5,[[]]],[11,"left_child","","<strong>O(1)</strong>, get left child index of node x.",5,[[]]],[11,"right_child","","<strong>O(1)</strong>, get right child index of node x.",5,[[]]],[11,"parent","","<strong>O(1)</strong>, get parent index of node x.",5,[[]]],[11,"root","","<strong>O(1)</strong>, get root index.",5,[[]]],[11,"is_root","","<strong>O(1)</strong>, either node x is root or not.",5,[[]]],[11,"update","","<strong>O(log(n))</strong>, update segment tree, leaf[k] = x.",5,[[]]],[11,"update_with","","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …",5,[[]]],[11,"recursive_update","","<strong>O(log(i))</strong>, update from leaf to root.",5,[[]]],[11,"query","","<strong>O(log(n))</strong>, calculate f(l, l+1, ..., r-1). note the half …",5,[[]]],[11,"recursive_query","","<strong>O(log(n)-log(node))</strong>, calculate from root to leaf.",5,[[]]],[11,"bisect_left","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …",5,[[],["option",4]]],[11,"bisect_right","","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …",5,[[],["option",4]]],[0,"segtree","aclib::collections::segtree","",null,null],[8,"Monoid","aclib::collections::segtree::segtree","",null,null],[10,"identity","","identity element of Monoid",6,[[]]],[10,"operation","","binary operation that satisfy associative law for Monoid",6,[[]]],[10,"into","","unwrap monoid for return value",6,[[]]],[3,"SegmentTree","","",null,null],[11,"new","","<strong>O(n)</strong>, create segment tree. (e is identity element for a …",7,[[]]],[11,"len","","<strong>O(1)</strong>, return this segtree \'s number of data",7,[[]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",7,[[]]],[11,"update","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …",7,[[]]],[11,"update_with","","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …",7,[[]]],[11,"indices","","<strong>O(1)</strong>, range to leaf index half interval [left, right).",7,[[]]],[11,"query","","<strong>O(log(n))</strong>, calculate f(range). (non-recursive)",7,[[]]],[11,"bisect","","<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …",7,[[],["option",4]]],[0,"sorted_vec","aclib::collections","",null,null],[3,"SortedVec","aclib::collections::sorted_vec","should use binary search tree",null,null],[11,"new","","<strong>O(1)</strong>, get empty vec",8,[[]]],[11,"iter","","<strong>O(1)</strong>, get iterator of vec",8,[[],["iter",3]]],[11,"insert","","<strong>O(n)</strong>, insert element",8,[[]]],[11,"max_elements","","<strong>O(k)</strong>, max k elements",8,[[]]],[11,"min_elements","","<strong>O(k)</strong>, min k elements",8,[[]]],[0,"unionfind","aclib::collections","",null,null],[0,"smooth_unionfind","aclib::collections::unionfind","",null,null],[3,"UnionFind","aclib::collections::unionfind::smooth_unionfind","",null,null],[11,"new","","<strong>O(n)</strong>, create n trees with themselves as roots",9,[[]]],[11,"union","","<strong>O(log(n))</strong>, marge 2 trees with primary and standby roots",9,[[]]],[11,"find","","<strong>O(log(n))</strong>, find the root of x, and update the roots of …",9,[[]]],[11,"equiv","","<strong>O(log(n))</strong>, check does x and y belong same root",9,[[]]],[0,"unionfind","aclib::collections::unionfind","",null,null],[3,"UnionFind","aclib::collections::unionfind::unionfind","",null,null],[11,"new","","<strong>O(n)</strong>, create n trees with themselves as roots",10,[[]]],[11,"union","","<strong>worst: O(n)</strong>, marge 2 trees with primary and standby roots",10,[[]]],[11,"find","","<strong>worst: O(n)</strong>, find the root of x",10,[[]]],[0,"with_petgraph","aclib::collections::unionfind","example of how to use petgraph::unionfind::Unionfind",null,null],[0,"cumsum","aclib","",null,null],[0,"cumsum1d","aclib::cumsum","",null,null],[3,"CumSum","aclib::cumsum::cumsum1d","",null,null],[11,"new","","<strong>O(n)</strong>, create n+1 size vec for cumsum",11,[[]]],[11,"interval_sum","","<strong>O(1)</strong>, calculate half-open interval summation [l, r)",11,[[]]],[0,"imos1d","aclib::cumsum","",null,null],[3,"Imos1D","aclib::cumsum::imos1d","",null,null],[11,"new","","<strong>O(n)</strong>, create n+1 size vec for imos 1d",12,[[["option",4]]]],[11,"sum_timing","","<strong>O(1)</strong>, calculate sum of timing t",12,[[]]],[0,"graph","aclib","",null,null],[0,"dijkstra","aclib::graph","",null,null],[5,"dijkstra","aclib::graph::dijkstra","<strong>O((n+m)log(n))</strong>, shortest path cost, with dijkstra …",null,[[["hashmap",3]],["option",4]]],[0,"with_petgraph","aclib::graph","",null,null],[0,"arbitrary","aclib::graph::with_petgraph","example of how to use petgraph::Graph::from_edges",null,null],[0,"grid","","",null,null],[5,"field_to_directed_grid","aclib::graph::with_petgraph::grid","<strong>O(hw)</strong>, make directed grid like graph from map (\'.\' is …",null,[[]]],[0,"search","aclib::graph::with_petgraph","",null,null],[0,"without_petgraph","aclib::graph","",null,null],[0,"dijkstra","aclib::graph::without_petgraph","",null,null],[3,"MinHeapRecord","aclib::graph::without_petgraph::dijkstra","",null,null],[0,"search","aclib::graph::without_petgraph","",null,null],[0,"structure","","",null,null],[4,"Undirected","aclib::graph::without_petgraph::structure","",null,null],[4,"Directed","","",null,null],[4,"Unweighted","","",null,null],[4,"Weighted","","",null,null],[13,"Weight","","",13,null],[3,"AdjacencyList","","weighted/unweighted and directed/undirected graph …",null,null],[11,"new_unweighted_undirected","","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) …",14,[[]]],[11,"new_unweighted_directed","","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) …",14,[[]]],[11,"new_weighted_undirected","","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …",14,[[]]],[11,"new_weighted_directed","","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …",14,[[]]],[11,"weight","","<strong>O(1)</strong>, get weight of edge",14,[[]]],[11,"neighbors","","<strong>O(1)</strong>, get node\'s neighbors set reference",14,[[],["hashset",3]]],[11,"nodes_len","","<strong>O(1)</strong>, number of nodes",14,[[]]],[11,"add_node","","<strong>O(1)</strong>, add node and return its index",14,[[]]],[11,"remove_node","","<strong>O(1)</strong>, remove node and return its neighbors if possible  <strong>…",14,[[],[["hashset",3],["option",4]]]],[0,"integer","aclib","",null,null],[0,"counting","aclib::integer","",null,null],[3,"Counting","aclib::integer::counting","",null,null],[11,"new","","<strong>O(n)</strong>, ready to compute combination(n,k) mod p, where p is …",15,[[]]],[11,"factorial","","<strong>O(1)</strong>, compute n! mod p",15,[[]]],[11,"permutation","","<strong>O(1)</strong>, compute nPk mod p",15,[[]]],[11,"combination","","<strong>O(1)</strong>, compute nCk mod p",15,[[]]],[11,"combination_with_repetition","","<strong>O(1)</strong>, compute nHk mod p",15,[[]]],[0,"devisors","aclib::integer","",null,null],[5,"devisors_pair","aclib::integer::devisors","<strong>O(sqrt(n))</strong>, calculate vec of pair os devisors",null,[[["unsigned",8],["copy",8],["integer",8],["toprimitive",8]],["vec",3]]],[5,"devisors","","<strong>O(sqrt(n))</strong>, calculate vec of devisors",null,[[["unsigned",8],["copy",8],["integer",8],["toprimitive",8]],[["unsigned",8],["copy",8],["integer",8],["toprimitive",8],["vec",3]]]],[0,"gcd","aclib::integer","",null,null],[5,"gcd_recursive","aclib::integer::gcd","<strong>O(|v| log(min(v))</strong>, calculate gcd recursively",null,[[["vec",3]],[["copy",8],["integer",8]]]],[5,"lcm_recursive","","<strong>O(|v| log(min(v)))</strong>, calculate lcm recursively",null,[[["vec",3]],[["copy",8],["integer",8]]]],[0,"modulo","aclib::integer","",null,null],[5,"mod_pow","aclib::integer::modulo","<strong>O(log(b))</strong>, calculate a^b % modulo",null,[[["copy",8],["integer",8]],[["copy",8],["integer",8]]]],[5,"mod_pow_u64","","<strong>O(log(b))</strong>, calculate a^b % modulo",null,[[]]],[5,"ex_euclid","","<strong>O(log(min(a, b)))</strong>, calculate pair (gcd(a,b), x, y) such …",null,[[["copy",8],["integer",8],["signed",8]]]],[5,"inverse_mod_mul","","<strong>O(log(min(a, modulo)))</strong>, calculate inverse element of a in …",null,[[["copy",8],["integer",8],["signed",8]],[["copy",8],["integer",8],["signed",8],["option",4]]]],[0,"prime","aclib::integer","",null,null],[3,"SieveOfEratosthenes","aclib::integer::prime","",null,null],[12,"min_primes","","",16,null],[11,"new","","<strong>O(n log(log(n)))</strong>, calculate n+1 size sieve, which vec[i] …",16,[[]]],[11,"is_prime","","<strong>O(1)</strong>, if num is prime then return true, else return false",16,[[]]],[11,"sieve","","<strong>O(n)</strong>, calculate n+1 size vec, which vec[i] mean i is …",16,[[],["vec",3]]],[11,"primes","","<strong>O(n)</strong>, calculate vec of primes from 0 to max",16,[[],["vec",3]]],[11,"factorization","","<strong>O(log(n))</strong>, calculate prime factorization of n, with …",16,[[],["hashmap",3]]],[5,"fast_primes","","<strong>O(n)...?</strong>, calculate vec of primes from 0 to max",null,[[],["vec",3]]],[5,"factorization","","<strong>O(sqrt(n))</strong>, calculate prime factorization of n",null,[[],["hashmap",3]]],[0,"sort","aclib::integer","",null,null],[5,"counting_sorted","aclib::integer::sort","<strong>O(n + (max(data)-min(data)))</strong>, return stable sorted data.",null,[[],[["copy",8],["integer",8],["asprimitive",8],["vec",3]]]],[5,"counting_sorted_with","","<strong>O(n + (max(f(data))-min(f(data))))</strong>, return stable sorted …",null,[[],["vec",3]]],[5,"radix_sorted","","<strong>O(n(log(max(data)))</strong>, return stable sorted data.",null,[[],[["copy",8],["integer",8],["asprimitive",8],["vec",3]]]],[5,"radix_sorted_with","","<strong>O(n(log(max(f(data))))</strong>, return stable sorted data.",null,[[],["vec",3]]],[0,"knapsack","aclib","",null,null],[0,"dp","aclib::knapsack","",null,null],[5,"knapsack_dp_value","aclib::knapsack::dp","<strong>O(sum(v)n)</strong>, knapsack capacity is c, value of pi is v[i], …",null,[[["copy",8],["integer",8]],[["vec",3],["vec",3]]]],[5,"knapsack_dp_value_solve","","<strong>O(sum(v)n)</strong>, solve knapsack with value-dp",null,[[["copy",8],["integer",8]]]],[5,"knapsack_dp_weight","","<strong>O(cn)</strong>, knapsack capacity is c, value of pi is v[i], …",null,[[],[["vec",3],["vec",3]]]],[5,"dp_weight_with_backtrack","","<strong>O(cn)</strong>, compute vec of products from table made by …",null,[[],["vec",3]]],[0,"meet_in_the_middle","aclib::knapsack","",null,null],[5,"knapsack_half_enumerate","aclib::knapsack::meet_in_the_middle","<strong>O(2^(n/2))</strong>, knapsack capacity is c, value of pi is v[i], …",null,[[]]],[0,"solver","aclib::knapsack","",null,null],[5,"knapsack","aclib::knapsack::solver","",null,[[]]],[0,"macros","aclib","",null,null],[0,"compare","aclib::macros","",null,null],[0,"summation","","",null,null],[14,"max","aclib","<strong>O(n)</strong>, max for one or more values",null,null],[14,"min","","<strong>O(n)</strong>, min for one or more values",null,null],[14,"sum","","<strong>O(n)</strong>, sum for values",null,null],[14,"prod","","<strong>O(n)</strong>, prod for values",null,null],[14,"mean","","<strong>O(n)</strong>, average for values",null,null],[11,"from","aclib::collections::linkedlist::singly","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"vzip","","",1,[[]]],[11,"from","aclib::collections::segtree::lazy_segtree::addtree","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"vzip","","",2,[[]]],[11,"from","aclib::collections::segtree::non_copy","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"vzip","","",3,[[]]],[11,"from","aclib::collections::segtree::non_recursive","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"vzip","","",4,[[]]],[11,"from","aclib::collections::segtree::recursive","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"vzip","","",5,[[]]],[11,"from","aclib::collections::segtree::segtree","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"vzip","","",7,[[]]],[11,"from","aclib::collections::sorted_vec","",8,[[]]],[11,"into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"vzip","","",8,[[]]],[11,"from","aclib::collections::unionfind::smooth_unionfind","",9,[[]]],[11,"into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"vzip","","",9,[[]]],[11,"from","aclib::collections::unionfind::unionfind","",10,[[]]],[11,"into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"vzip","","",10,[[]]],[11,"from","aclib::cumsum::cumsum1d","",11,[[]]],[11,"into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"vzip","","",11,[[]]],[11,"from","aclib::cumsum::imos1d","",12,[[]]],[11,"into","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"vzip","","",12,[[]]],[11,"from","aclib::graph::without_petgraph::dijkstra","",17,[[]]],[11,"into","","",17,[[]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"equivalent","","",17,[[]]],[11,"vzip","","",17,[[]]],[11,"from","aclib::graph::without_petgraph::structure","",18,[[]]],[11,"into","","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"vzip","","",18,[[]]],[11,"from","","",19,[[]]],[11,"into","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"vzip","","",19,[[]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"vzip","","",20,[[]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"vzip","","",13,[[]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"vzip","","",14,[[]]],[11,"from","aclib::integer::counting","",15,[[]]],[11,"into","","",15,[[]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"vzip","","",15,[[]]],[11,"from","aclib::integer::prime","",16,[[]]],[11,"into","","",16,[[]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"vzip","","",16,[[]]],[11,"drop","aclib::collections::linkedlist::singly","<strong>O(n)</strong>, drop remain nodes",1,[[]]],[11,"extend","","<strong>O(n)</strong>, extends items as tails",1,[[["intoiterator",8]]]],[11,"extend","aclib::collections::sorted_vec","<strong>O(n + k log(k))</strong>, extend elements (size k)",8,[[["intoiterator",8]]]],[11,"cmp","aclib::graph::without_petgraph::dijkstra","",17,[[],["ordering",4]]],[11,"eq","","",17,[[["minheaprecord",3]]]],[11,"ne","","",17,[[["minheaprecord",3]]]],[11,"partial_cmp","","",17,[[],[["option",4],["ordering",4]]]],[11,"index","aclib::collections::segtree::non_copy","<strong>O(1)...?</strong>, this function seem to make size n temporary …",3,[[]]],[11,"index","aclib::collections::segtree::non_recursive","<strong>O(1)...?</strong>, this function seem to make size n temporary …",4,[[]]],[11,"index","aclib::collections::sorted_vec","<strong>O(size(index))</strong>, get the element(s) of at the index of the …",8,[[]]],[11,"index","aclib::graph::without_petgraph::structure","<strong>O(1)</strong>, get weight of edge",14,[[]]],[11,"index","","<strong>O(1)</strong>, get node\'s neighbors set",14,[[]]],[11,"index_mut","aclib::collections::segtree::non_copy","<strong>O(1)...?</strong>, this function seem to make size n temporary …",3,[[]]],[11,"from_iter","aclib::collections::sorted_vec","<strong>O(n log(n))</strong>, make sorted list from iterator",8,[[["intoiterator",8]]]],[11,"dijkstra","aclib::graph::without_petgraph::structure","<strong>O((n+m)log(n))</strong>, shortest path number of hops and its …",14,[[]]],[11,"dijkstra","","<strong>O((n+m)log(n))</strong>, shortest path distance and its route, …",14,[[]]],[11,"bfs","","<strong>O(n)</strong>, return breadth first search order",14,[[],["vec",3]]],[11,"dfs","","<strong>O(n)</strong>, return depth first search order",14,[[],["vec",3]]]],"p":[[8,"Counter"],[3,"LinkedList"],[3,"AddTree"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"SegmentTree"],[8,"Monoid"],[3,"SegmentTree"],[3,"SortedVec"],[3,"UnionFind"],[3,"UnionFind"],[3,"CumSum"],[3,"Imos1D"],[4,"Weighted"],[3,"AdjacencyList"],[3,"Counting"],[3,"SieveOfEratosthenes"],[3,"MinHeapRecord"],[4,"Undirected"],[4,"Directed"],[4,"Unweighted"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);