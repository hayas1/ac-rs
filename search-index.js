var searchIndex = JSON.parse('{\
"lib":{"doc":"Rust practice: Data structure and AlgorithmsThe goal is to…","i":[[0,"counter","lib","",null,null],[0,"counter_copy","lib::counter","",null,null],[8,"Counter","lib::counter::counter_copy","",null,null],[10,"new","","",0,[[["iterator",8]]]],[10,"count","","",0,[[]]],[10,"most_common","","",0,[[],["vec",3]]],[0,"cumsum","lib","",null,null],[0,"cumsum1d","lib::cumsum","",null,null],[3,"CumSum","lib::cumsum::cumsum1d","",null,null],[11,"new","","O(n), create n+1 size vec for cumsum",1,[[]]],[11,"interval_sum","","O(1), calculate half-open interval summation [l, r)",1,[[]]],[0,"imos1d","lib::cumsum","",null,null],[3,"Imos1D","lib::cumsum::imos1d","",null,null],[11,"new","","O(n), create n+1 size vec for imos 1d",2,[[["option",4]]]],[11,"sum_timing","","O(1), calculate sum of timing t",2,[[]]],[0,"distance","lib","",null,null],[0,"levenshtein","lib::distance","",null,null],[5,"levenshtein_distance","lib::distance::levenshtein","O(nm), calculate edit distance between sequence a and…",null,[[]]],[0,"manhattan_chebyshev","lib::distance","",null,null],[5,"manhattan_distance_2d","lib::distance::manhattan_chebyshev","O(1), calculate manhattan distance between two point of…",null,[[],[["copy",8],["integer",8]]]],[5,"rotate_45","","O(n), 45-degree rotation, manhattan distance become to be…",null,[[],["vec",3]]],[5,"chebyshev_distance_2d","","O(1), calculate chebyshev distance between two point of…",null,[[],[["copy",8],["integer",8]]]],[5,"manhattan_distance","","O(n), calculate manhattan distance between two point of…",null,[[],[["copy",8],["integer",8]]]],[5,"chebyshev_distance","","O(n), calculate chebyshev distance between two point of…",null,[[],[["copy",8],["integer",8]]]],[0,"graph","lib","",null,null],[0,"arbitrary","lib::graph","example of how to use petgraph::Graph::from_edges show…",null,null],[0,"grid","","",null,null],[5,"field_to_directed_grid","lib::graph::grid","O(hw), make directed grid like graph from map (\'.\' is…",null,[[]]],[0,"integer","lib","",null,null],[0,"counting","lib::integer","",null,null],[3,"Counting","lib::integer::counting","",null,null],[11,"new","","O(n), ready to compute combination(n,k) mod p, where p is…",3,[[]]],[11,"factorial","","O(1), compute n! mod p",3,[[]]],[11,"permutation","","O(1), compute nPk mod p",3,[[]]],[11,"combination","","O(1), compute nCk mod p",3,[[]]],[11,"combination_with_repetition","","O(1), compute nHk mod p",3,[[]]],[0,"gcd","lib::integer","",null,null],[5,"gcd_recursive","lib::integer::gcd","O(|v| log(min(v)), calculate gcd recursively",null,[[["vec",3]],[["copy",8],["integer",8]]]],[5,"lcm_recursive","","O(|v| log(min(v))), calculate lcm recursively",null,[[["vec",3]],[["copy",8],["integer",8]]]],[0,"modulo","lib::integer","",null,null],[5,"mod_pow","lib::integer::modulo","O(log(b)), calculate a^b % modulo",null,[[["integer",8],["copy",8]],[["copy",8],["integer",8]]]],[5,"mod_pow_u64","","O(log(b)), calculate a^b % modulo",null,[[]]],[5,"ex_euclid","","O(log(min(a, b))), calculate pair (gcd(a,b), x, y) such…",null,[[["integer",8],["copy",8],["signed",8]]]],[5,"inverse_mod_mul","","O(log(min(a, modulo))), calculate inverse element of a in…",null,[[["integer",8],["copy",8],["signed",8]],[["copy",8],["integer",8],["option",4],["signed",8]]]],[0,"prime","lib::integer","",null,null],[5,"sieve_of_eratosthenes","lib::integer::prime","O(n log(log(n))), calculate n size vec, which vec[i] mean…",null,[[],["vec",3]]],[5,"primes","","O(n log(log(n))), calculate vec of primes from 0 to max",null,[[],["vec",3]]],[5,"fast_primes","","O(n)...? calculate vec of primes from 0 to max",null,[[],["vec",3]]],[5,"min_primes","","O(n log(log(n))), calculate vec, which vec[i] mean…",null,[[],["vec",3]]],[5,"factorization","","O(sqrt(n)), calculate prime factorization of n",null,[[],["hashmap",3]]],[5,"factorization_with_min_primes","","O(log(n)), calculate prime factorization of n, with…",null,[[],["hashmap",3]]],[5,"devisors","","O(sqrt(n)), calculate vec of devisors",null,[[],["vec",3]]],[0,"sort","lib::integer","",null,null],[5,"counting_sorted","lib::integer::sort","O(n + (max(data)-min(data))), return stable sorted data.",null,[[],["vec",3]]],[5,"counting_sorted_with","","O(n + (max(f(data))-min(f(data)))), return stable sorted…",null,[[],["vec",3]]],[5,"radix_sorted_with","","O(n(log(max(f(data)))), return stable sorted data.",null,[[],["vec",3]]],[0,"knapsack","lib","",null,null],[0,"dp","lib::knapsack","",null,null],[5,"knapsack_dp_value","lib::knapsack::dp","O(sum(v)n), knapsack capacity is c, value of pi is v[i],…",null,[[["integer",8],["copy",8]],[["vec",3],["vec",3]]]],[5,"knapsack_dp_value_solve","","O(sum(v)n), solve knapsack with value-dp",null,[[["integer",8],["copy",8]]]],[5,"knapsack_dp_weight","","O(cn), knapsack capacity is c, value of pi is v[i], weight…",null,[[],[["vec",3],["vec",3]]]],[5,"dp_weight_with_backtrack","","O(cn), compute vec of products from table made by…",null,[[],["vec",3]]],[0,"meet_in_the_middle","lib::knapsack","",null,null],[5,"knapsack_half_enumerate","lib::knapsack::meet_in_the_middle","O(2^(n/2), knapsack capacity is c, value of pi is v[i],…",null,[[]]],[0,"solver","lib::knapsack","",null,null],[5,"knapsack","lib::knapsack::solver","",null,[[]]],[0,"segmenttree","lib","",null,null],[0,"non_copy","lib::segmenttree","",null,null],[3,"SegmentTree","lib::segmenttree::non_copy","",null,null],[11,"from","","O(n), create segment tree, note that this method requires…",4,[[["vec",3]]]],[11,"leaf_offset","","O(1), get beginning index of the segment tree leaf.",4,[[]]],[11,"update","","O(log(n)), set leaf[k] = x, and update segment tree.…",4,[[]]],[11,"update_with","","O(log(n)), update leaf[k] by f(leaf[k]), and update…",4,[[]]],[11,"swap","","O(log(n)), swap leaf[k] and leaf[l], and update segment…",4,[[]]],[11,"update_parents","","O(log(n)), update segment tree. (non-recursive)",4,[[]]],[11,"query","","O(log(n)), calculate f(l, l+1, ..., r-1). note the half…",4,[[]]],[11,"bisect_left","","O(log^2(n)), search the leftmost leaf where cmp(x) is true…",4,[[],["option",4]]],[11,"bisect_right","","O(log^2(n)), search the rightmost leaf where cmp(x) is…",4,[[],["option",4]]],[0,"non_recursive","lib::segmenttree","",null,null],[3,"SegmentTree","lib::segmenttree::non_recursive","",null,null],[11,"new","","O(n), create segment tree. (e is identity element for a…",5,[[]]],[11,"leaf_offset","","O(1), get beginning index of the segment tree leaf.",5,[[]]],[11,"num_of_leaf","","O(1), get size of leaves",5,[[]]],[11,"update","","O(log(n)), set leaf[k] = x, and update segment tree.…",5,[[]]],[11,"update_with","","O(log(n)), update leaf[k] by f(leaf[k]), and update…",5,[[]]],[11,"swap","","O(log(n)), swap leaf[k] and leaf[l], and update segment…",5,[[]]],[11,"query","","O(log(n)), calculate f(l, l+1, ..., r-1). note the half…",5,[[]]],[11,"bisect_left","","O(log^2(n)), search the leftmost leaf where cmp(x) is true…",5,[[],["option",4]]],[11,"bisect_right","","O(log^2(n)), search the rightmost leaf where cmp(x) is…",5,[[],["option",4]]],[0,"recursive","lib::segmenttree","",null,null],[3,"SegmentTree","lib::segmenttree::recursive","",null,null],[11,"new","","O(n), create segment tree. (e is identity element for a…",6,[[]]],[11,"leaf_offset","","O(1), get beginning index of the segment tree leaf.",6,[[]]],[11,"num_of_leaf","","O(1), get size of leaves.",6,[[]]],[11,"left_child","","O(1), get left child index of node x.",6,[[]]],[11,"right_child","","O(1), get right child index of node x.",6,[[]]],[11,"parent","","O(1), get parent index of node x.",6,[[]]],[11,"root","","O(1), get root index.",6,[[]]],[11,"is_root","","O(1), either node x is root or not.",6,[[]]],[11,"update","","O(log(n)), update segment tree, leaf[k] = x.",6,[[]]],[11,"update_with","","O(log(n)), update leaf[k] by f(leaf[k]), and update…",6,[[]]],[11,"recursive_update","","O(log(i)), update from leaf to root.",6,[[]]],[11,"query","","O(log(n)), calculate half-open interval summation from l…",6,[[]]],[11,"recursive_query","","O(log(n)-log(node)), calculate summation from root to leaf.",6,[[]]],[11,"bisect_left","","O(log^2(n)), search the leftmost leaf where cmp(x) is true…",6,[[],["option",4]]],[11,"bisect_right","","O(log^2(n)), search the rightmost leaf where cmp(x) is…",6,[[],["option",4]]],[0,"unionfind","lib","",null,null],[0,"smooth_unionfind","lib::unionfind","",null,null],[3,"UnionFind","lib::unionfind::smooth_unionfind","",null,null],[11,"new","","O(n), create n trees with themselves as roots",7,[[]]],[11,"union","","O(log(n)), marge 2 trees with primary and standby roots",7,[[]]],[11,"find","","O(log(n)), find the root of x, and update the roots of…",7,[[]]],[11,"equiv","","O(log(n)), check does x and y belong same root",7,[[]]],[0,"unionfind","lib::unionfind","",null,null],[3,"UnionFind","lib::unionfind::unionfind","",null,null],[11,"new","","O(n), create n trees with themselves as roots",8,[[]]],[11,"union","","worst: O(n), marge 2 trees with primary and standby roots",8,[[]]],[11,"find","","worst: O(n), find the root of x",8,[[]]],[0,"with_petgraph","lib::unionfind","example of how to use petgraph::unionfind::Unionfind; show…",null,null],[11,"from","lib::cumsum::cumsum1d","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","lib::cumsum::imos1d","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","lib::integer::counting","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","lib::segmenttree::non_copy","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","lib::segmenttree::non_recursive","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","lib::segmenttree::recursive","",6,[[]]],[11,"into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","lib::unionfind::smooth_unionfind","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","lib::unionfind::unionfind","",8,[[]]],[11,"into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"index","lib::segmenttree::non_copy","O(n)...? this function might make size n temporary slice",4,[[]]],[11,"index","lib::segmenttree::non_recursive","O(n)...? this function might make size n temporary slice",5,[[]]],[11,"index_mut","lib::segmenttree::non_copy","O(n)...? this function might make size n temporary slice",4,[[]]]],"p":[[8,"Counter"],[3,"CumSum"],[3,"Imos1D"],[3,"Counting"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"UnionFind"],[3,"UnionFind"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);