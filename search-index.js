var searchIndex = JSON.parse('{\
"aclib":{"doc":"Rust practice: Data structure and Algorithms","t":[0,0,0,0,0,0,0,0,14,14,14,14,14,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,8,10,10,11,10,10,10,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,0,0,0,0,0,8,3,11,11,11,10,11,10,11,10,11,11,11,11,10,11,11,11,11,11,11,0,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,8,3,11,11,11,11,10,11,10,11,11,11,11,10,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,0,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,0,0,5,5,0,0,0,6,0,0,5,0,0,5,5,5,5,0,0,0,0,0,5,5,5,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,3,4,4,4,13,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,0,0,0,0,0,0,0,0,0,3,11,11,11,11,11,11,11,11,11,11,11,11,5,5,5,5,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,12,11,11,11,11,11,11,5,5,5,5,0,0,0,5,5,5,5,5,5,0,0],"n":["algo","collections","cumsum","dic_order","graph","integer","knapsack","macros","max","mean","min","prod","sum","bisect","bound","compress","distance","inversion","sort","two_pointers","bisect","bisect_left","bisect_left_by_key","bisect_right","bisect_right_by_key","bisect_unit","initial_indices","log_ceil","log_floor","sqrt_ceil","sqrt_floor","bisect_right","lower_bound","upper_bound","coordinate_compress","hamming","levenshtein","manhattan_chebyshev","hamming_distance","levenshtein_distance","chebyshev_distance","chebyshev_distance_2d","manhattan_distance","manhattan_distance_2d","rotate_45","inversion_number","inversion_number_with","bubble_sort","heap_sort","insertion_sort","merge_sort","quick_sort","selection_sort","two_pointers","counter","heap","linkedlist","segtree","sorted_vec","trie_tree","unionfind","Counter","count","counted","from","most_common","new","remove","non_recursive","recursive","MinHeap","borrow","borrow_mut","down_heap","from","from","into","len","new","peek","pop","push","try_from","try_into","type_id","up_heap","BHeapSet","borrow","borrow_mut","down_heap","from","from","heapify","into","len","new","peek","pop","push","try_from","try_into","type_id","up_heap","singly","LinkedList","append","borrow","borrow_mut","dequeue","drop","enqueue","extend","from","into","is_empty","len","new","peek_head","peek_tail","pop","push","try_from","try_into","type_id","custom_tree","lazy_segtree","non_copy","non_recursive","recursive","segtree","Monoid","SegmentTree","bisect","borrow","borrow_mut","from","from","identity","indices","into","into","leaf_offset","len","new","operation","query","try_from","try_into","type_id","update","update_with","addtree","AddTree","borrow","borrow_mut","from","into","leaf_offset","new","num_of_leaf","propagation","query","recursive_query","recursive_update_range","try_from","try_into","type_id","update_range","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","from","index","index_mut","into","leaf_offset","query","swap","try_from","try_into","type_id","update","update_parents","update_with","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","index","into","leaf_offset","new","num_of_leaf","query","swap","try_from","try_into","type_id","update","update_with","SegmentTree","bisect_left","bisect_right","borrow","borrow_mut","from","into","is_root","leaf_offset","left_child","new","num_of_leaf","parent","query","recursive_query","recursive_update","right_child","root","try_from","try_into","type_id","update","update_with","Monoid","SegmentTree","bisect","borrow","borrow_mut","from","identity","indices","into","into","leaf_offset","len","new","operation","query","try_from","try_into","type_id","update","update_with","SortedVec","borrow","borrow_mut","extend","from","from_iter","index","insert","into","iter","max_elements","min_elements","new","try_from","try_into","type_id","TrieTree","borrow","borrow_mut","contains","fmt","from","insert","into","new","remove","try_from","try_into","type_id","merge_technique","smooth_unionfind","unionfind","with_petgraph","MergeTechnique","borrow","borrow_mut","find","from","into","new","same_group","size","try_from","try_into","type_id","union","UnionFind","borrow","borrow_mut","connected_components","equiv","find","from","into","new","root","size","try_from","try_into","type_id","union","UnionFind","borrow","borrow_mut","find","from","into","new","try_from","try_into","type_id","union","cumsum1d","imos1d","CumSum","borrow","borrow_mut","from","from_iter","from_iter","indices","interval_sum","into","try_from","try_into","type_id","with_data","Imos1D","borrow","borrow_mut","from","into","new","sum_timing","try_from","try_into","type_id","bfs","next_permutation","kth_dic_order","next_permutation","algo","with_petgraph","without_petgraph","NodeId","dijkstra","euler_tour","undirected_neighbors","one_to_many","one_to_one","dijkstra","from_to_indices","dijkstra","euler_tour","arbitrary","bipartite","diameter","grid","search","is_bipartite","diameter_of_tree","field_to_directed_grid","dijkstra","search","structure","MinHeapRecord","borrow","borrow_mut","cmp","eq","equivalent","from","into","partial_cmp","try_from","try_into","type_id","AdjacencyList","Directed","Undirected","Unweighted","Weight","Weighted","add_node","bfs","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","dfs","dijkstra","dijkstra","from","from","from","from","from","index","index","into","into","into","into","into","neighbors","new_unweighted_directed","new_unweighted_undirected","new_weighted_directed","new_weighted_undirected","nodes_len","remove_node","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","weight","0","counting","devisors","gcd","modint","modulo","prime","rational","sieve","sort","Counting","borrow","borrow_mut","combination","combination_with_repetition","factorial","from","into","new","permutation","try_from","try_into","type_id","devisors","devisors_pair","gcd_recursive","lcm_recursive","ModInt","add","add_assign","borrow","borrow_mut","clone","clone_into","cmp","eq","equivalent","fmt","fmt","from","into","mul","mul_assign","new","partial_cmp","sub","sub_assign","to_owned","to_string","try_from","try_into","type_id","ex_euclid","inverse_mod_mul","mod_pow","mod_pow_u64","factorization","fast_primes","Rational","add","add_assign","borrow","borrow_mut","clone","clone_into","cmp","common","div","div_assign","eq","equivalent","fmt","fmt","from","into","irreducible","mul","mul_assign","new","partial_cmp","sub","sub_assign","to_owned","to_string","try_from","try_into","type_id","SieveOfEratosthenes","borrow","borrow_mut","euler_phi","factorization","from","into","is_prime","min_primes","new","primes","sieve","try_from","try_into","type_id","counting_sorted","counting_sorted_with","radix_sorted","radix_sorted_with","dp","meet_in_the_middle","solver","dp_weight_with_backtrack","knapsack_dp_value","knapsack_dp_value_solve","knapsack_dp_weight","knapsack_half_enumerate","knapsack","compare","summation"],"q":["aclib","","","","","","","","","","","","","aclib::algo","","","","","","","aclib::algo::bisect","","","","","","","","","","","aclib::algo::bound","","","aclib::algo::compress","aclib::algo::distance","","","aclib::algo::distance::hamming","aclib::algo::distance::levenshtein","aclib::algo::distance::manhattan_chebyshev","","","","","aclib::algo::inversion","","aclib::algo::sort","","","","","","aclib::algo::two_pointers","aclib::collections","","","","","","","aclib::collections::counter","","","","","","","aclib::collections::heap","","aclib::collections::heap::non_recursive","","","","","","","","","","","","","","","","aclib::collections::heap::recursive","","","","","","","","","","","","","","","","","aclib::collections::linkedlist","aclib::collections::linkedlist::singly","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree","","","","","","aclib::collections::segtree::custom_tree","","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::lazy_segtree","aclib::collections::segtree::lazy_segtree::addtree","","","","","","","","","","","","","","","","aclib::collections::segtree::non_copy","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::non_recursive","","","","","","","","","","","","","","","","","","aclib::collections::segtree::recursive","","","","","","","","","","","","","","","","","","","","","","","aclib::collections::segtree::segtree","","","","","","","","","","","","","","","","","","","","aclib::collections::sorted_vec","","","","","","","","","","","","","","","","aclib::collections::trie_tree","","","","","","","","","","","","","aclib::collections::unionfind","","","","aclib::collections::unionfind::merge_technique","","","","","","","","","","","","","aclib::collections::unionfind::smooth_unionfind","","","","","","","","","","","","","","","aclib::collections::unionfind::unionfind","","","","","","","","","","","aclib::cumsum","","aclib::cumsum::cumsum1d","","","","","","","","","","","","","aclib::cumsum::imos1d","","","","","","","","","","aclib::dic_order","","aclib::dic_order::bfs","aclib::dic_order::next_permutation","aclib::graph","","","aclib::graph::algo","","","","aclib::graph::algo::dijkstra","","aclib::graph::algo::dijkstra::one_to_many","","aclib::graph::algo::dijkstra::one_to_one","aclib::graph::algo::euler_tour","aclib::graph::with_petgraph","","","","","aclib::graph::with_petgraph::bipartite","aclib::graph::with_petgraph::diameter","aclib::graph::with_petgraph::grid","aclib::graph::without_petgraph","","","aclib::graph::without_petgraph::dijkstra","","","","","","","","","","","","aclib::graph::without_petgraph::structure","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","aclib::graph::without_petgraph::structure::Weighted","aclib::integer","","","","","","","","","aclib::integer::counting","","","","","","","","","","","","","aclib::integer::devisors","","aclib::integer::gcd","","aclib::integer::modint","","","","","","","","","","","","","","","","","","","","","","","","","aclib::integer::modulo","","","","aclib::integer::prime","","aclib::integer::rational","","","","","","","","","","","","","","","","","","","","","","","","","","","","","aclib::integer::sieve","","","","","","","","","","","","","","","aclib::integer::sort","","","","aclib::knapsack","","","aclib::knapsack::dp","","","","aclib::knapsack::meet_in_the_middle","aclib::knapsack::solver","aclib::macros",""],"d":["","","","","","","","","<strong>O(n)</strong>, max for one or more values","<strong>O(n)</strong>, average for values","<strong>O(n)</strong>, min for one or more values","<strong>O(n)</strong>, prod for values","<strong>O(n)</strong>, sum for values","","","","","","","","<strong>O(log(ans))</strong>, find the first index at which false -&gt; true …","<strong>O(log(n))</strong>, find the leftmost insertion index with key …","<strong>O(log(n))</strong>, find the leftmost insertion index with key …","<strong>O(log(n))</strong>, find the rightmost insertion index with key …","<strong>O(log(n))</strong>, find the rightmost insertion index with key …","<strong>O(log(ans/unit))</strong>, find the first index (width: <code>unit</code>) at …","<strong>O(log(end-start))</strong>, return (start, end) that f(end) == true …","<strong>O(log())</strong>, calculate log_a(x) by ceil (warning: overflow)","<strong>O(log())</strong>, calculate log_a(x) by floor (warning: overflow)","<strong>O(log(x))</strong>, calculate square root of x by ceil (warning: …","<strong>O(log(x))</strong>, calculate square root of x by floor (warning: …","<strong>O(log(|a|))</strong>, return the last index i such that a[i] &lt;= x","<strong>O(log(|a|))</strong>, return the first index i such that a[i] &gt;= x","<strong>O(log(|a|))</strong>, return the first index i such that a[i] &gt; x","<strong>O(n log(n))</strong>, return compressed vector","","","","<strong>O(n)</strong>, get hamming distance between a and b such as a.len() …","<strong>O(nm)</strong>, calculate edit distance between sequence a and …","<strong>O(n)</strong>, calculate chebyshev distance between two point of …","<strong>O(1)</strong>, calculate chebyshev distance between two point of …","<strong>O(n)</strong>, calculate manhattan distance between two point of …","<strong>O(1)</strong>, calculate manhattan distance between two point of …","<strong>O(n)</strong>, 45-degree rotation, manhattan distance become to be …","<strong>O(n log(n))</strong>, calculate inversion number, on data such as …","<strong>O(n log(n))</strong>, calculate inversion number for deduplicated …","<strong>O(n^2)</strong>, stable sorted by bubble sort","<strong>O(n log(n))</strong>, sorted by heap sort","<strong>O(n + inversion_number(data))</strong>, stable sorted by insertion …","<strong>O(n log(n))</strong>, stable sorted by merge sort","<strong>O(n log(n))</strong>, sorted data by quick sort","<strong>O(n^2)</strong>, stable sorted by selection sort","<strong>O(n)</strong>, get iterator of two pointer method. (if cond is true …","","","","","","","","","<strong>O(1)</strong>, count new element","<strong>O(1)</strong>, count the number of occurrences of elem","<strong>O(n)</strong>, count duplicate elements data","<strong>O(n log(usize::MAX))</strong>, get vec with sorted in descending …","<strong>O(n)</strong>, new empty counter","<strong>O(1)</strong>, remove element","","","","","","<strong>O(log(n))</strong>, heapify to leaf without recursive","Returns the argument unchanged.","<strong>O(n)</strong>, heapify in place (it is well known that bottom-up …","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, return the number of elements in this heap","<strong>O(1)</strong>, create min heap with operation that return total …","<strong>O(1)</strong>, peek min item","<strong>O(log(n))</strong>, pop min item","<strong>O(log(n))</strong>, push new item","","","","<strong>O(log(n))</strong>, heapify to root without recursive","","","","<strong>O(log(n))</strong>, heapify subtree","Returns the argument unchanged.","<strong>O(n)</strong>, heapify in place","<strong>O(n)</strong>, heapify","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, return the number of elements in this heap","<strong>O(1)</strong>, create min heap with operation that return total …","<strong>O(1)</strong>, peek min item","<strong>O(log(n))</strong>, pop min item","<strong>O(log(n))</strong>, push new item","","","","<strong>O(log(n))</strong>, heapify to root","","","<strong>O(1)</strong>, append the other linked list","","","<strong>O(1)</strong>, return and remove head item","<strong>O(n)</strong>, drop remain nodes","<strong>O(1)</strong>, add new item to the end of the list","<strong>O(n)</strong>, extends items as tails","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, return true if the list has no item, else return …","<strong>O(1)</strong>, return length of the list","<strong>O(1)</strong>, return empty linked list","<strong>O(1)</strong>, peek the top of the list","<strong>O(1)</strong>, peek the end of the list","<strong>O(1)</strong>, return and remove head item","<strong>O(1)</strong>, add new item to the top of the list","","","","","","","","","","","","<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …","","","wrap input to Monoid","Returns the argument unchanged.","identity element of Monoid","<strong>O(1)</strong>, range to leaf index half interval [left, right).","unwrap from monoid","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, return this segtree ’s number of data","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","binary operation that satisfy associative law for Monoid","<strong>O(log(n))</strong>, calculate f(range). (non-recursive)","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves","<strong>O(log(n))?</strong>, propagate lazy value to children","<strong>O(log^2(n))?</strong>, calculate half-open interval summation from …","<strong>O(log^2(n))?</strong>, calculate summation from root to leaf.","<strong>O(log^2(n))?</strong>, set lazy value from root to leaf","","","","<strong>O(log(n))</strong>, update the half interval [l, r) with add x.","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","<strong>O(n)</strong>, create segment tree, note that this method requires …","Returns the argument unchanged.","<strong>O(1)…?</strong>, this function seem to make size n temporary …","<strong>O(1)…?</strong>, this function seem to make size n temporary …","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update segment tree. (non-recursive)","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","Returns the argument unchanged.","<strong>O(1)…?</strong>, this function seem to make size n temporary …","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, either node x is root or not.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, get left child index of node x.","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","<strong>O(1)</strong>, get size of leaves.","<strong>O(1)</strong>, get parent index of node x.","<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …","<strong>O(log(n)-log(node))</strong>, calculate from root to leaf.","<strong>O(log(i))</strong>, update from leaf to root.","<strong>O(1)</strong>, get right child index of node x.","<strong>O(1)</strong>, get root index.","","","","<strong>O(log(n))</strong>, update segment tree, leaf[k] = x.","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","","","<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …","","","Returns the argument unchanged.","identity element of Monoid","<strong>O(1)</strong>, range to leaf index half interval [left, right).","unwrap monoid for return value","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get beginning index of the segment tree leaf.","<strong>O(1)</strong>, return this segtree ’s number of data","<strong>O(n)</strong>, create segment tree. (e is identity element for a …","binary operation that satisfy associative law for Monoid","<strong>O(log(n))</strong>, calculate f(range). (non-recursive)","","","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …","should use binary search tree","","","<strong>O(n + k log(k))</strong>, extend elements (size k)","Returns the argument unchanged.","<strong>O(n log(n))</strong>, make sorted list from iterator","<strong>O(size(index))</strong>, get the element(s) of at the index of the …","<strong>O(n)</strong>, insert element","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get iterator of vec","<strong>O(k)</strong>, max k elements","<strong>O(k)</strong>, min k elements","<strong>O(1)</strong>, get empty vec","","","","","","","<strong>O(m)</strong>, judge key is inserted or not","","Returns the argument unchanged.","<strong>O(m)</strong>, insert key","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, make empty trie tree","<strong>O(m)</strong>, remove key (WARNING: unimplemented!)","","","","","","","example of how to use petgraph::unionfind::Unionfind","","","","<strong>O(log(n))</strong>, find the root of x, and update the roots of …","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, create n trees with themselves as roots","<strong>O(log(n))</strong>, return members in same group (warning: returned …","<strong>O(log(n))</strong>, return number of members in same group","","","","<strong>O(log(n))</strong>, marge a’s trees and b’s tree, if already …","","","","<strong>O(n log(n))</strong>, get connected components (HashMap&lt;parent, …","<strong>O(log(n))</strong>, check does x and y belong same root","<strong>O(log(n))</strong>, find the root of x, and update the roots of …","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, create n trees with themselves as roots","<strong>O(log(n))</strong>, get root of x, this method is immutable","<strong>O(log(n))</strong>, return size of connected component","","","","<strong>O(log(n))</strong>, marge 2 trees with primary and standby roots, …","","","","<strong>worst: O(n)</strong>, find the root of x","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, create n trees with themselves as roots","","","","<strong>worst: O(n)</strong>, marge 2 trees with primary and standby roots","","","","","","Returns the argument unchanged.","<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed iterator","<strong>O(n)</strong>, create n+1 size vec for cumsum from iterator","<strong>O(1)</strong>, range to index half interval [left, right).","<strong>O(1)</strong>, calculate half-open interval summation r","Calls <code>U::from(self)</code>.","","","","<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed iterator","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, create n+1 size vec for imos 1d","<strong>O(1)</strong>, calculate sum of timing t","","","","","","<strong>O(|candidate| * (kinds of chars)^2)</strong>, generate the kth item …","<strong>O(n)</strong>, generate next item in dictionary order, in place","","","","","","","","","","<strong>O((n+m)log(n))</strong>, shortest paths cost, with dijkstra …","","<strong>O((n+m)log(n))</strong>, shortest path cost, with dijkstra algorithm","<strong>O(n+m)</strong>, get visited time and left time by dfs","example of how to use petgraph::Graph::from_edges","","","","","<em><strong>O(m log(n))</strong></em>, check bipartite graph (warning: expect simple …","<strong>O(n)</strong>, return diameter of given tree","<strong>O(hw)</strong>, make directed grid like graph from map (‘.’ is …","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","weighted/unweighted and directed/undirected graph structure","","","","","","<strong>O(1)</strong>, add node and return its index","<strong>O(n)</strong>, return breadth first search order","","","","","","","","","","","<strong>O(n)</strong>, return depth first search order","<strong>O((n+m)log(n))</strong>, shortest path distance and its route, with …","<strong>O((n+m)log(n))</strong>, shortest path number of hops and its …","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","<strong>O(1)</strong>, get weight of edge","<strong>O(1)</strong>, get node’s neighbors set","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, get node’s neighbors set reference","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) to …","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) to …","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …","<strong>O(1)</strong>, number of nodes","<strong>O(1)</strong>, remove node and return its neighbors if possible  …","","","","","","","","","","","","","","","","<strong>O(1)</strong>, get weight of edge","","","","","","","","","","","","","","<strong>O(1)</strong>, compute nCk mod p","<strong>O(1)</strong>, compute nHk mod p","<strong>O(1)</strong>, compute n! mod p","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(n)</strong>, ready to compute combination(n,k) mod p, where p is …","<strong>O(1)</strong>, compute nPk mod p","","","","<strong>O(sqrt(n))</strong>, calculate vec of devisors","<strong>O(sqrt(n))</strong>, calculate vec of pair os devisors","<strong>O(|v| log(min(v))</strong>, calculate gcd recursively","<strong>O(|v| log(min(v)))</strong>, calculate lcm recursively","","","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","<strong>O(log(min(a, b)))</strong>, calculate pair (gcd(a,b), x, y) such …","<strong>O(log(min(a, modulo)))</strong>, calculate inverse element of a in …","<strong>O(log(b))</strong>, calculate a^b % modulo","<strong>O(log(b))</strong>, calculate a^b % modulo","<strong>O(sqrt(n))</strong>, calculate prime factorization of n","<strong>O(n)…?</strong>, calculate vec of primes from 0 to max","","","","","","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","prime number is calculated as a index of Vec, so their …","","","<strong>O(log(n))</strong>, the number of integers that are prime to n each …","<strong>O(log(n))</strong>, calculate prime factorization of n, with …","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<strong>O(1)</strong>, if num is prime then return true, else return false","","<strong>O(n log(log(n)))</strong>, calculate size n+1 sieve, which vec[i] …","<strong>O(n)</strong>, calculate vec of primes from 0 to max","<strong>O(n)</strong>, returned vec[i] mean i is prime or not","","","","<strong>O(n + (max(data)-min(data)))</strong>, return stable sorted data.","<strong>O(n + (max(f(data))-min(f(data))))</strong>, return stable sorted …","<strong>O(n(log(max(data)))</strong>, return stable sorted data.","<strong>O(n(log(max(f(data))))</strong>, return stable sorted data.","","","","<strong>O(cn)</strong>, compute vec of products from table made by …","<strong>O(sum(v)n)</strong>, knapsack capacity is c, value of pi is v[i], …","<strong>O(sum(v)n)</strong>, solve knapsack with value-dp","<strong>O(cn)</strong>, knapsack capacity is c, value of pi is v[i], weight …","<strong>O(2^(n/2))</strong>, knapsack capacity is c, value of pi is v[i], …","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65,65,65,65,65,65,0,0,0,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,0,19,19,19,66,19,66,19,66,19,19,19,19,66,19,19,19,19,19,19,0,0,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,0,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,0,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,0,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,0,0,26,26,26,26,67,26,67,26,26,26,26,67,26,26,26,26,26,26,0,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,0,30,30,30,30,30,30,30,30,30,30,30,30,0,0,0,0,0,34,34,34,34,34,34,34,34,34,34,34,34,0,36,36,36,36,36,36,36,36,36,36,36,36,36,36,0,38,38,38,38,38,38,38,38,38,38,0,0,0,42,42,42,42,42,42,42,42,42,42,42,42,0,44,44,44,44,44,44,44,44,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,46,46,46,46,46,46,46,46,46,46,0,0,0,0,50,0,49,49,53,52,51,50,49,53,52,51,50,49,49,49,49,53,52,51,50,49,49,49,53,52,51,50,49,49,49,49,49,49,49,49,53,52,51,50,49,53,52,51,50,49,53,52,51,50,49,49,68,0,0,0,0,0,0,0,0,0,0,54,54,54,54,54,54,54,54,54,54,54,54,0,0,0,0,0,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,0,0,0,0,0,0,0,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,0,63,63,63,63,63,63,63,63,63,63,63,63,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[],1],[2,3],[[],3],[2,3],[[],3],[[],1],[[]],[[]],[[]],[[[0,[4,2,5,6,7]]],[[0,[4,2,5,6,7]]]],[[[0,[4,2,5,6,7]]],[[0,[4,2,5,6,7]]]],[2,3],[2,3],[2,3],[[],[[8,[3]]]],0,0,0,[[9,9],3],[[],3],[[],[[0,[7,10]]]],[[],[[0,[7,10]]]],[[],[[0,[7,10]]]],[[],[[0,[7,10]]]],[[],8],[[],3],[[],3],[[]],[[]],[[]],[[]],[[]],[[]],[[],11],0,0,0,0,0,0,0,0,[[]],[[],3],[9],[[],8],[[]],[[]],0,0,0,[[]],[[]],[[12,3]],[[]],[8,12],[[]],[12,3],[[],12],[12,1],[12,1],[12],[[],13],[[],13],[[],14],[[12,3]],0,[[]],[[]],[[15,3]],[[]],[8,15],[15],[[]],[15,3],[[],15],[15,1],[15,1],[15],[[],13],[[],13],[[],14],[[15,3]],0,0,[[16,16]],[[]],[[]],[16,1],[16],[16],[[16,9]],[[]],[[]],[16,17],[16,3],[[],16],[16,[[1,[18]]]],[16,[[1,[18]]]],[16,1],[16],[[],13],[[],13],[[],14],0,0,0,0,0,0,0,0,[[19,17],[[1,[3]]]],[[]],[[]],[[]],[[]],[[]],[19],[[]],[[]],[19,3],[19,3],[[],19],[[]],[19],[[],13],[[],13],[[],14],[[19,3]],[[19,3]],0,0,[[]],[[]],[[]],[[]],[[[21,[[0,[7,20,10]]]]],3],[[],[[21,[[0,[7,20,10]]]]]],[[[21,[[0,[7,20,10]]]]],3],[[[21,[[0,[7,20,10]]]],3]],[[[21,[[0,[7,20,10]]]],3,3],[[0,[7,20,10]]]],[[[21,[[0,[7,20,10]]]],3,3,3,3,3],[[0,[7,20,10]]]],[[[21,[[0,[7,20,10]]]],3,3,3,3,3,[0,[7,20,10]]]],[[],13],[[],13],[[],14],[[[21,[[0,[7,20,10]]]],3,3,[0,[7,20,10]]]],0,[[22,3,3],[[1,[3]]]],[[22,3,3],[[1,[3]]]],[[]],[[]],[8,22],[[]],[[22,23]],[[22,23]],[[]],[22,3],[[22,3,3]],[[22,3,3]],[[],13],[[],13],[[],14],[[22,3]],[[22,3]],[[22,3]],0,[[[24,[10]],3,3],[[1,[3]]]],[[[24,[10]],3,3],[[1,[3]]]],[[]],[[]],[[]],[[[24,[10]],23]],[[]],[[[24,[10]]],3],[10,[[24,[10]]]],[[[24,[10]]],3],[[[24,[10]],3,3],10],[[[24,[10]],3,3]],[[],13],[[],13],[[],14],[[[24,[10]],3,10],10],[[[24,[10]],3],10],0,[[[25,[10]],3,3],[[1,[3]]]],[[[25,[10]],3,3],[[1,[3]]]],[[]],[[]],[[]],[[]],[3,17],[[[25,[10]]],3],[3,3],[10,[[25,[10]]]],[[[25,[10]]],3],[3,3],[[[25,[10]],3,3],10],[[[25,[10]],3,3,3,3,3],10],[[[25,[10]],3]],[3,3],[[],3],[[],13],[[],13],[[],14],[[[25,[10]],3,10]],[[[25,[10]],3]],0,0,[[26,17],[[1,[3]]]],[[]],[[]],[[]],[[]],[26],[[]],[[]],[26,3],[26,3],[[],26],[[]],[26],[[],13],[[],13],[[],14],[[26,3]],[[26,3]],0,[[]],[[]],[[[28,[27]],9]],[[]],[9,[[28,[27]]]],[[[28,[27]],23]],[[[28,[27]],27]],[[]],[[[28,[27]]],[[29,[27]]]],[[[28,[27]],3]],[[[28,[27]],3]],[[],[[28,[27]]]],[[],13],[[],13],[[],14],0,[[]],[[]],[30,17],[[[30,[31]],32],33],[[]],[30,17],[[]],[[],30],[30,17],[[],13],[[],13],[[],14],0,0,0,0,0,[[]],[[]],[[34,3],3],[[]],[[]],[3,34],[[34,3],35],[[34,3],3],[[],13],[[],13],[[],14],[[34,3,3],17],0,[[]],[[]],[36,[[37,[3,[8,[3]]]]]],[[36,3,3],17],[[36,3],3],[[]],[[]],[3,36],[[36,3],3],[[36,3],3],[[],13],[[],13],[[],14],[[36,3,3],17],0,[[]],[[]],[[38,3],3],[[]],[[]],[3,38],[[],13],[[],13],[[],14],[[38,3,3],3],0,0,0,[[]],[[]],[[]],[9,[[42,[[0,[4,39,40,41]]]]]],[9,[[42,[[0,[4,39,40,41]]]]]],[[[42,[[0,[4,39,40,41]]]],[43,[3]]]],[[[42,[[0,[4,39,40,41]]]],[43,[3]]],[[0,[4,39,40,41]]]],[[]],[[],13],[[],13],[[],14],[[],[[42,[[0,[4,39,40,41]]]]]],0,[[]],[[]],[[]],[[]],[[[1,[3]]],44],[[44,3]],[[],13],[[],13],[[],14],0,0,[3,8],[[],17],0,0,0,0,0,0,[3,[[37,[3,[35,[3]]]]]],0,0,[37,37],[37],[37,1],[[37,3]],0,0,0,0,0,[3,17],[45,3],[[]],0,0,0,0,[[]],[[]],[[[46,[27]],[46,[27]]],47],[[[46,[[0,[48,27]]]],46],17],[[],17],[[]],[[]],[[[46,[27]],[46,[27]]],[[1,[47]]]],[[],13],[[],13],[[],14],0,0,0,0,0,0,[49,3],[[49,3],[[8,[3]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[49,3],[[8,[3]]]],[[[49,[[50,[[0,[10,39,27,41]]]]]],3,3]],[[[49,[51]],3,3]],[[]],[[]],[[]],[[]],[[]],[[[49,[[50,[10]]]]]],[[49,3]],[[]],[[]],[[]],[[]],[[]],[[49,3],35],[[],[[49,[51,52]]]],[[],[[49,[51,53]]]],[[],[[49,[[50,[10]],52]]]],[[],[[49,[[50,[10]],53]]]],[49,3],[[49,3],[[1,[[35,[3]]]]]],[[],13],[[],13],[[],13],[[],13],[[],13],[[],13],[[],13],[[],13],[[],13],[[],13],[[],14],[[],14],[[],14],[[],14],[[],14],[[[49,[[50,[10]]]],3,3],10],0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[[54,[[0,[7,10,20]]]],3,3],[[0,[7,10,20]]]],[[[54,[[0,[7,10,20]]]],3,3],[[0,[7,10,20]]]],[[[54,[[0,[7,10,20]]]],3],[[0,[7,10,20]]]],[[]],[[]],[[3,[0,[7,10,20]]],[[54,[[0,[7,10,20]]]]]],[[[54,[[0,[7,10,20]]]],3,3],[[0,[7,10,20]]]],[[],13],[[],13],[[],14],[[[0,[7,55,56,10]]],[[8,[[0,[7,55,56,10]]]]]],[[[0,[7,55,56,10]]],8],[8,[[0,[7,10]]]],[8,[[0,[7,10]]]],0,[[[57,[[0,[7,10]]]],[57,[[0,[7,10]]]]]],[[[57,[[0,[7,10]]]],[57,[[0,[7,10]]]]]],[[]],[[]],[[[57,[[0,[4,7,10]]]]],[[57,[[0,[4,7,10]]]]]],[[]],[[[57,[[0,[27,7,10]]]],57],47],[[[57,[[0,[48,7,10]]]],57],17],[[],17],[[[57,[[0,[31,7,10]]]],32],33],[[[57,[[0,[58,7,10]]]],32],33],[[]],[[]],[[[57,[[0,[7,10]]]],[57,[[0,[7,10]]]]]],[[[57,[[0,[7,10]]]],[57,[[0,[7,10]]]]]],[[[0,[7,10]],[0,[7,10]]],[[57,[[0,[7,10]]]]]],[[[57,[[0,[2,7,10]]]],57],[[1,[47]]]],[[[57,[[0,[7,10]]]],[57,[[0,[7,10]]]]]],[[[57,[[0,[7,10]]]],[57,[[0,[7,10]]]]]],[[]],[[],59],[[],13],[[],13],[[],14],[[[0,[7,60,10]],[0,[7,60,10]]]],[[[0,[7,60,10]],[0,[7,60,10]]],[[1,[[0,[7,60,10]]]]]],[[[0,[7,10]],[0,[7,10]],[0,[7,10]]],[[0,[7,10]]]],[[61,61,61],61],[61,[[37,[61,3]]]],[3,[[8,[3]]]],0,[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[]],[[]],[[[62,[[0,[4,7,10]]]]],[[62,[[0,[4,7,10]]]]]],[[]],[[[62,[[0,[27,7,10]]]],62],47],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]],17],[[],17],[[[62,[[0,[31,7,10]]]],32],33],[[[62,[[0,[58,7,10]]]],32],33],[[]],[[]],[[[62,[[0,[7,10]]]]],[[62,[[0,[7,10]]]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[[0,[7,10]],[0,[7,10]]],[[1,[[62,[[0,[7,10]]]]]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]],[[1,[47]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[[62,[[0,[7,10]]]],[62,[[0,[7,10]]]]]],[[]],[[],59],[[],13],[[],13],[[],14],0,[[]],[[]],[[63,3],3],[[63,3],[[37,[3,3]]]],[[]],[[]],[[63,3],17],0,[3,63],[63,[[8,[3]]]],[63,[[8,[17]]]],[[],13],[[],13],[[],14],[[],[[8,[[0,[[64,[3]],10]]]]]],[[],8],[[],[[8,[[0,[[64,[3]],10]]]]]],[[],8],0,0,0,[[3,3],[[8,[3]]]],[[3,[0,[7,10]]],[[8,[[8,[[1,[[0,[7,10]]]]]]]]]],[[3,[0,[7,10]]],3],[[3,3],[[8,[[8,[[0,[7,10]]]]]]]],[3],[3],0,0],"p":[[4,"Option"],[8,"PartialOrd"],[15,"usize"],[8,"Clone"],[8,"AddAssign"],[8,"SubAssign"],[8,"Integer"],[3,"Vec"],[8,"IntoIterator"],[8,"Copy"],[3,"IntoIter"],[3,"MinHeap"],[4,"Result"],[3,"TypeId"],[3,"BHeapSet"],[3,"LinkedList"],[15,"bool"],[3,"Ref"],[3,"SegmentTree"],[8,"NumCast"],[3,"AddTree"],[3,"SegmentTree"],[8,"SliceIndex"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"SegmentTree"],[8,"Ord"],[3,"SortedVec"],[3,"Iter"],[3,"TrieTree"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[3,"MergeTechnique"],[3,"HashSet"],[3,"UnionFind"],[3,"HashMap"],[3,"UnionFind"],[8,"Add"],[8,"Sub"],[8,"Zero"],[3,"CumSum"],[8,"RangeBounds"],[3,"Imos1D"],[6,"UnGraph"],[3,"MinHeapRecord"],[4,"Ordering"],[8,"PartialEq"],[3,"AdjacencyList"],[4,"Weighted"],[4,"Unweighted"],[4,"Directed"],[4,"Undirected"],[3,"Counting"],[8,"ToPrimitive"],[8,"Unsigned"],[3,"ModInt"],[8,"Display"],[3,"String"],[8,"Signed"],[15,"u64"],[3,"Rational"],[3,"SieveOfEratosthenes"],[8,"AsPrimitive"],[8,"Counter"],[8,"Monoid"],[8,"Monoid"],[13,"Weight"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
