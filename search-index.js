var searchIndex = JSON.parse('{\
"aclib":{"doc":"Rust practice: Data structure and AlgorithmsThe goal is …","i":[[0,"algo","aclib","",null,null],[0,"bisect","aclib::algo","",null,null],[5,"initial_indices","aclib::algo::bisect","<strong>O(log(end-start))</strong>, return (start, end) that f(end) == …",null,[[]]],[5,"bisect_unit","","<strong>O(log(ans/unit))</strong>, find the first index (width: <code>unit</code>) at …",null,[[],["option",4]]],[5,"bisect","","<strong>O(log(ans))</strong>, find the first index at which false -> true …",null,[[],["option",4]]],[5,"sqrt_ceil","","<strong>O(log(x))</strong>, calculate square root of x by ceil (warning: …",null,[[["integer",8],["partialord",8],["clone",8],["subassign",8],["addassign",8]],[["integer",8],["partialord",8],["clone",8],["subassign",8],["addassign",8]]]],[5,"sqrt_floor","","<strong>O(log(x))</strong>, calculate square root of x by floor (warning: …",null,[[["integer",8],["partialord",8],["clone",8],["subassign",8],["addassign",8]],[["integer",8],["partialord",8],["clone",8],["subassign",8],["addassign",8]]]],[5,"log_ceil","","<strong>O(log())</strong>, calculate log_a(x) by ceil (warning: overflow)",null,[[]]],[5,"log_floor","","<strong>O(log())</strong>, calculate log_a(x) by floor (warning: overflow)",null,[[]]],[5,"bisect_left_by_key","","<strong>O(log(n))</strong>, find the leftmost insertion index with key …",null,[[],["usize",15]]],[5,"bisect_left","","<strong>O(log(n))</strong>, find the leftmost insertion index with key …",null,[[["partialord",8]],["usize",15]]],[5,"bisect_right_by_key","","<strong>O(log(n))</strong>, find the rightmost insertion index with key …",null,[[],["usize",15]]],[5,"bisect_right","","<strong>O(log(n))</strong>, find the rightmost insertion index with key …",null,[[["partialord",8]],["usize",15]]],[0,"distance","aclib::algo","",null,null],[0,"levenshtein","aclib::algo::distance","",null,null],[5,"levenshtein_distance","aclib::algo::distance::levenshtein","<strong>O(nm)</strong>, calculate edit distance between sequence a and …",null,[[],["usize",15]]],[0,"manhattan_chebyshev","aclib::algo::distance","",null,null],[5,"manhattan_distance_2d","aclib::algo::distance::manhattan_chebyshev","<strong>O(1)</strong>, calculate manhattan distance between two point of …",null,[[],[["integer",8],["copy",8]]]],[5,"rotate_45","","<strong>O(n)</strong>, 45-degree rotation, manhattan distance become to be …",null,[[],["vec",3]]],[5,"chebyshev_distance_2d","","<strong>O(1)</strong>, calculate chebyshev distance between two point of …",null,[[],[["integer",8],["copy",8]]]],[5,"manhattan_distance","","<strong>O(n)</strong>, calculate manhattan distance between two point of …",null,[[],[["integer",8],["copy",8]]]],[5,"chebyshev_distance","","<strong>O(n)</strong>, calculate chebyshev distance between two point of …",null,[[],[["integer",8],["copy",8]]]],[0,"inversion","aclib::algo","",null,null],[5,"inversion_number","aclib::algo::inversion","<strong>O(n log(n))</strong>, calculate inversion number, on data such as …",null,[[],["usize",15]]],[5,"inversion_number_with","","<strong>O(n log(n))</strong>, calculate inversion number for deduplicated …",null,[[],["usize",15]]],[0,"sort","aclib::algo","",null,null],[5,"bubble_sort","aclib::algo::sort","<strong>O(n^2)</strong>, stable sorted by bubble sort",null,[[]]],[5,"selection_sort","","<strong>O(n^2)</strong>, stable sorted by selection sort",null,[[]]],[5,"insertion_sort","","<strong>O(n + inversion_number(data))</strong>, stable sorted by insertion …",null,[[]]],[5,"heap_sort","","<strong>O(n log(n))</strong>, sorted by heap sort",null,[[]]],[5,"merge_sort","","<strong>O(n log(n))</strong>, stable sorted by merge sort",null,[[]]],[5,"quick_sort","","<strong>O(n log(n))</strong>, sorted data by quick sort",null,[[]]],[0,"collections","aclib","",null,null],[0,"counter","aclib::collections","",null,null],[8,"Counter","aclib::collections::counter","",null,null],[10,"new","","",0,[[["iterator",8]]]],[10,"count","","",0,[[],["usize",15]]],[10,"most_common","","",0,[[],["vec",3]]],[0,"linkedlist","aclib::collections","",null,null],[0,"singly","aclib::collections::linkedlist","",null,null],[3,"LinkedList","aclib::collections::linkedlist::singly","",null,null],[11,"new","","<strong>O(1)</strong>, return empty linked list",1,[[]]],[11,"len","","<strong>O(1)</strong>, return length of the list",1,[[],["usize",15]]],[11,"is_empty","","<strong>O(1)</strong>, return true if the list has no item, else return …",1,[[],["bool",15]]],[11,"peek_head","","<strong>O(1)</strong>, peek the top of the list",1,[[],[["option",4],["ref",3]]]],[11,"peek_tail","","<strong>O(1)</strong>, peek the end of the list",1,[[],[["option",4],["ref",3]]]],[11,"push","","<strong>O(1)</strong>, add new item to the top of the list",1,[[]]],[11,"pop","","<strong>O(1)</strong>, return and remove head item",1,[[],["option",4]]],[11,"enqueue","","<strong>O(1)</strong>, add new item to the end of the list",1,[[]]],[11,"dequeue","","<strong>O(1)</strong>, return and remove head item",1,[[],["option",4]]],[11,"append","","<strong>O(1)</strong>, append the other linked list",1,[[]]],[0,"segtree","aclib::collections","",null,null],[0,"lazy_segtree","aclib::collections::segtree","",null,null],[0,"addtree","aclib::collections::segtree::lazy_segtree","",null,null],[3,"AddTree","aclib::collections::segtree::lazy_segtree::addtree","",null,null],[11,"new","","<strong>O(n)</strong>, create segment tree. (e is identity element for a …",2,[[]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",2,[[],["usize",15]]],[11,"num_of_leaf","","<strong>O(1)</strong>, get size of leaves",2,[[],["usize",15]]],[11,"update_range","","<strong>O(log(n))</strong>, update the half interval [l, r) with add x.",2,[[["usize",15]]]],[11,"recursive_update_range","","<strong>O(log^2(n))?</strong>, set lazy value from root to leaf",2,[[["usize",15]]]],[11,"query","","<strong>O(log^2(n))?</strong>, calculate half-open interval summation from …",2,[[["usize",15]]]],[11,"recursive_query","","<strong>O(log^2(n))?</strong>, calculate summation from root to leaf.",2,[[["usize",15]]]],[11,"propagation","","<strong>O(log(n))?</strong>, propagate lazy value to children",2,[[["usize",15]]]],[0,"non_copy","aclib::collections::segtree","",null,null],[3,"SegmentTree","aclib::collections::segtree::non_copy","",null,null],[11,"from","","<strong>O(n)</strong>, create segment tree, note that this method requires …",3,[[["vec",3]]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",3,[[],["usize",15]]],[11,"update","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …",3,[[["usize",15]]]],[11,"update_with","","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …",3,[[["usize",15]]]],[11,"swap","","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …",3,[[["usize",15]]]],[11,"update_parents","","<strong>O(log(n))</strong>, update segment tree. (non-recursive)",3,[[["usize",15]]]],[11,"query","","<strong>O(log(n))</strong>, calculate f(l, l+1, ..., r-1). note the half …",3,[[["usize",15]]]],[11,"bisect_left","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …",3,[[["usize",15]],[["usize",15],["option",4]]]],[11,"bisect_right","","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …",3,[[["usize",15]],[["usize",15],["option",4]]]],[0,"non_recursive","aclib::collections::segtree","",null,null],[3,"SegmentTree","aclib::collections::segtree::non_recursive","",null,null],[11,"new","","<strong>O(n)</strong>, create segment tree. (e is identity element for a …",4,[[]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",4,[[],["usize",15]]],[11,"num_of_leaf","","<strong>O(1)</strong>, get size of leaves",4,[[],["usize",15]]],[11,"update","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …",4,[[["usize",15]]]],[11,"update_with","","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …",4,[[["usize",15]]]],[11,"swap","","<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …",4,[[["usize",15]]]],[11,"query","","<strong>O(log(n))</strong>, calculate f(l, l+1, ..., r-1). note the half …",4,[[["usize",15]]]],[11,"bisect_left","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …",4,[[["usize",15]],[["usize",15],["option",4]]]],[11,"bisect_right","","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …",4,[[["usize",15]],[["usize",15],["option",4]]]],[0,"recursive","aclib::collections::segtree","",null,null],[3,"SegmentTree","aclib::collections::segtree::recursive","",null,null],[11,"new","","<strong>O(n)</strong>, create segment tree. (e is identity element for a …",5,[[]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",5,[[],["usize",15]]],[11,"num_of_leaf","","<strong>O(1)</strong>, get size of leaves.",5,[[],["usize",15]]],[11,"left_child","","<strong>O(1)</strong>, get left child index of node x.",5,[[["usize",15]],["usize",15]]],[11,"right_child","","<strong>O(1)</strong>, get right child index of node x.",5,[[["usize",15]],["usize",15]]],[11,"parent","","<strong>O(1)</strong>, get parent index of node x.",5,[[["usize",15]],["usize",15]]],[11,"root","","<strong>O(1)</strong>, get root index.",5,[[],["usize",15]]],[11,"is_root","","<strong>O(1)</strong>, either node x is root or not.",5,[[["usize",15]],["bool",15]]],[11,"update","","<strong>O(log(n))</strong>, update segment tree, leaf[k] = x.",5,[[["usize",15]]]],[11,"update_with","","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …",5,[[["usize",15]]]],[11,"recursive_update","","<strong>O(log(i))</strong>, update from leaf to root.",5,[[["usize",15]]]],[11,"query","","<strong>O(log(n))</strong>, calculate f(l, l+1, ..., r-1). note the half …",5,[[["usize",15]]]],[11,"recursive_query","","<strong>O(log(n)-log(node))</strong>, calculate from root to leaf.",5,[[["usize",15]]]],[11,"bisect_left","","<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is …",5,[[["usize",15]],[["usize",15],["option",4]]]],[11,"bisect_right","","<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …",5,[[["usize",15]],[["usize",15],["option",4]]]],[0,"segtree","aclib::collections::segtree","",null,null],[8,"Monoid","aclib::collections::segtree::segtree","",null,null],[10,"identity","","identity element of Monoid",6,[[]]],[10,"operation","","binary operation that satisfy associative law for Monoid",6,[[]]],[10,"into","","unwrap monoid for return value",6,[[]]],[3,"SegmentTree","","",null,null],[11,"new","","<strong>O(n)</strong>, create segment tree. (e is identity element for a …",7,[[]]],[11,"len","","<strong>O(1)</strong>, return this segtree \'s number of data",7,[[],["usize",15]]],[11,"leaf_offset","","<strong>O(1)</strong>, get beginning index of the segment tree leaf.",7,[[],["usize",15]]],[11,"update","","<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …",7,[[["usize",15]]]],[11,"update_with","","<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …",7,[[["usize",15]]]],[11,"indices","","<strong>O(1)</strong>, range to leaf index half interval [left, right).",7,[[]]],[11,"query","","<strong>O(log(n))</strong>, calculate f(range). (non-recursive)",7,[[]]],[11,"bisect","","<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …",7,[[["bool",15]],[["usize",15],["option",4]]]],[0,"sorted_vec","aclib::collections","",null,null],[3,"SortedVec","aclib::collections::sorted_vec","should use binary search tree",null,null],[11,"new","","<strong>O(1)</strong>, get empty vec",8,[[]]],[11,"iter","","<strong>O(1)</strong>, get iterator of vec",8,[[],["iter",3]]],[11,"insert","","<strong>O(n)</strong>, insert element",8,[[]]],[11,"max_elements","","<strong>O(k)</strong>, max k elements",8,[[["usize",15]]]],[11,"min_elements","","<strong>O(k)</strong>, min k elements",8,[[["usize",15]]]],[0,"trie_tree","aclib::collections","",null,null],[3,"TrieTree","aclib::collections::trie_tree","",null,null],[11,"new","","<strong>O(1)</strong>, make empty trie tree",9,[[]]],[11,"insert","","<strong>O(m)</strong>, insert key",9,[[],["bool",15]]],[11,"remove","","<strong>O(m)</strong>, remove key (WARNING: unimplemented!)",9,[[],["bool",15]]],[11,"contains","","<strong>O(m)</strong>, judge key is inserted or not",9,[[],["bool",15]]],[0,"unionfind","aclib::collections","",null,null],[0,"smooth_unionfind","aclib::collections::unionfind","",null,null],[3,"UnionFind","aclib::collections::unionfind::smooth_unionfind","",null,null],[11,"new","","<strong>O(n)</strong>, create n trees with themselves as roots",10,[[["usize",15]]]],[11,"union","","<strong>O(log(n))</strong>, marge 2 trees with primary and standby roots",10,[[["usize",15]],["bool",15]]],[11,"find","","<strong>O(log(n))</strong>, find the root of x, and update the roots of …",10,[[["usize",15]],["usize",15]]],[11,"equiv","","<strong>O(log(n))</strong>, check does x and y belong same root",10,[[["usize",15]],["bool",15]]],[0,"unionfind","aclib::collections::unionfind","",null,null],[3,"UnionFind","aclib::collections::unionfind::unionfind","",null,null],[11,"new","","<strong>O(n)</strong>, create n trees with themselves as roots",11,[[["usize",15]]]],[11,"union","","<strong>worst: O(n)</strong>, marge 2 trees with primary and standby roots",11,[[["usize",15]],["usize",15]]],[11,"find","","<strong>worst: O(n)</strong>, find the root of x",11,[[["usize",15]],["usize",15]]],[0,"with_petgraph","aclib::collections::unionfind","example of how to use petgraph::unionfind::Unionfind",null,null],[0,"cumsum","aclib","",null,null],[0,"cumsum1d","aclib::cumsum","",null,null],[3,"CumSum","aclib::cumsum::cumsum1d","",null,null],[11,"with_data","","<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed …",12,[[]]],[11,"indices","","<strong>O(1)</strong>, range to index half interval [left, right).",12,[[["usize",15],["rangebounds",8]]]],[11,"interval_sum","","<strong>O(1)</strong>, calculate half-open interval summation r",12,[[["usize",15],["rangebounds",8]]]],[0,"imos1d","aclib::cumsum","",null,null],[3,"Imos1D","aclib::cumsum::imos1d","",null,null],[11,"new","","<strong>O(n)</strong>, create n+1 size vec for imos 1d",13,[[["usize",15],["option",4]]]],[11,"sum_timing","","<strong>O(1)</strong>, calculate sum of timing t",13,[[["usize",15]]]],[0,"graph","aclib","",null,null],[0,"dijkstra","aclib::graph","",null,null],[0,"one_to_many","aclib::graph::dijkstra","",null,null],[5,"from_to_indices","aclib::graph::dijkstra::one_to_many","",null,[[["hashmap",3]]]],[5,"dijkstra","","<strong>O((n+m)log(n))</strong>, shortest paths cost, with dijkstra …",null,[[["hashmap",3]],["hashmap",3]]],[0,"one_to_one","aclib::graph::dijkstra","",null,null],[5,"dijkstra","aclib::graph::dijkstra::one_to_one","<strong>O((n+m)log(n))</strong>, shortest path cost, with dijkstra …",null,[[["hashmap",3]],["option",4]]],[0,"with_petgraph","aclib::graph","",null,null],[0,"arbitrary","aclib::graph::with_petgraph","example of how to use petgraph::Graph::from_edges",null,null],[0,"grid","","",null,null],[5,"field_to_directed_grid","aclib::graph::with_petgraph::grid","<strong>O(hw)</strong>, make directed grid like graph from map (\'.\' is …",null,[[]]],[0,"search","aclib::graph::with_petgraph","",null,null],[0,"diameter","","",null,null],[5,"diameter_of_tree","aclib::graph::with_petgraph::diameter","<strong>O(n)</strong>, return diameter of given tree",null,[[["ungraph",6]],["usize",15]]],[0,"without_petgraph","aclib::graph","",null,null],[0,"dijkstra","aclib::graph::without_petgraph","",null,null],[3,"MinHeapRecord","aclib::graph::without_petgraph::dijkstra","",null,null],[0,"search","aclib::graph::without_petgraph","",null,null],[0,"structure","","",null,null],[4,"Undirected","aclib::graph::without_petgraph::structure","",null,null],[4,"Directed","","",null,null],[4,"Unweighted","","",null,null],[4,"Weighted","","",null,null],[13,"Weight","","",14,null],[3,"AdjacencyList","","weighted/unweighted and directed/undirected graph …",null,null],[11,"new_unweighted_undirected","","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) …",15,[[]]],[11,"new_unweighted_directed","","<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) …",15,[[]]],[11,"new_weighted_undirected","","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …",15,[[]]],[11,"new_weighted_directed","","<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …",15,[[]]],[11,"weight","","<strong>O(1)</strong>, get weight of edge",15,[[["usize",15]]]],[11,"neighbors","","<strong>O(1)</strong>, get node\'s neighbors set reference",15,[[["usize",15]],["hashset",3]]],[11,"nodes_len","","<strong>O(1)</strong>, number of nodes",15,[[],["usize",15]]],[11,"add_node","","<strong>O(1)</strong>, add node and return its index",15,[[],["usize",15]]],[11,"remove_node","","<strong>O(1)</strong>, remove node and return its neighbors if possible  <strong>…",15,[[["usize",15]],[["option",4],["hashset",3]]]],[0,"integer","aclib","",null,null],[0,"counting","aclib::integer","",null,null],[3,"Counting","aclib::integer::counting","",null,null],[11,"new","","<strong>O(n)</strong>, ready to compute combination(n,k) mod p, where p is …",16,[[["usize",15]]]],[11,"factorial","","<strong>O(1)</strong>, compute n! mod p",16,[[["usize",15]]]],[11,"permutation","","<strong>O(1)</strong>, compute nPk mod p",16,[[["usize",15]]]],[11,"combination","","<strong>O(1)</strong>, compute nCk mod p",16,[[["usize",15]]]],[11,"combination_with_repetition","","<strong>O(1)</strong>, compute nHk mod p",16,[[["usize",15]]]],[0,"devisors","aclib::integer","",null,null],[5,"devisors_pair","aclib::integer::devisors","<strong>O(sqrt(n))</strong>, calculate vec of pair os devisors",null,[[["integer",8],["copy",8],["toprimitive",8],["unsigned",8]],["vec",3]]],[5,"devisors","","<strong>O(sqrt(n))</strong>, calculate vec of devisors",null,[[["integer",8],["copy",8],["toprimitive",8],["unsigned",8]],[["integer",8],["copy",8],["vec",3],["toprimitive",8],["unsigned",8]]]],[0,"gcd","aclib::integer","",null,null],[5,"gcd_recursive","aclib::integer::gcd","<strong>O(|v| log(min(v))</strong>, calculate gcd recursively",null,[[["vec",3]],[["integer",8],["copy",8]]]],[5,"lcm_recursive","","<strong>O(|v| log(min(v)))</strong>, calculate lcm recursively",null,[[["vec",3]],[["integer",8],["copy",8]]]],[0,"modulo","aclib::integer","",null,null],[5,"mod_pow","aclib::integer::modulo","<strong>O(log(b))</strong>, calculate a^b % modulo",null,[[["integer",8],["copy",8]],[["integer",8],["copy",8]]]],[5,"mod_pow_u64","","<strong>O(log(b))</strong>, calculate a^b % modulo",null,[[["u64",15]],["u64",15]]],[5,"ex_euclid","","<strong>O(log(min(a, b)))</strong>, calculate pair (gcd(a,b), x, y) such …",null,[[["integer",8],["copy",8],["signed",8]]]],[5,"inverse_mod_mul","","<strong>O(log(min(a, modulo)))</strong>, calculate inverse element of a in …",null,[[["integer",8],["copy",8],["signed",8]],[["integer",8],["copy",8],["option",4],["signed",8]]]],[0,"prime","aclib::integer","",null,null],[3,"SieveOfEratosthenes","aclib::integer::prime","",null,null],[12,"min_primes","","",17,null],[11,"new","","<strong>O(n log(log(n)))</strong>, calculate n+1 size sieve, which vec[i] …",17,[[["usize",15]]]],[11,"is_prime","","<strong>O(1)</strong>, if num is prime then return true, else return false",17,[[["usize",15]],["bool",15]]],[11,"sieve","","<strong>O(n)</strong>, calculate n+1 size vec, which vec[i] mean i is …",17,[[],[["bool",15],["vec",3]]]],[11,"primes","","<strong>O(n)</strong>, calculate vec of primes from 0 to max",17,[[],[["usize",15],["vec",3]]]],[11,"factorization","","<strong>O(log(n))</strong>, calculate prime factorization of n, with …",17,[[["usize",15]],[["hashmap",3],["usize",15]]]],[5,"fast_primes","","<strong>O(n)...?</strong>, calculate vec of primes from 0 to max",null,[[["usize",15]],[["usize",15],["vec",3]]]],[5,"factorization","","<strong>O(sqrt(n))</strong>, calculate prime factorization of n",null,[[["usize",15]],[["hashmap",3],["usize",15]]]],[0,"sort","aclib::integer","",null,null],[5,"counting_sorted","aclib::integer::sort","<strong>O(n + (max(data)-min(data)))</strong>, return stable sorted data.",null,[[],[["integer",8],["usize",15],["copy",8],["vec",3],["asprimitive",8]]]],[5,"counting_sorted_with","","<strong>O(n + (max(f(data))-min(f(data))))</strong>, return stable sorted …",null,[[],["vec",3]]],[5,"radix_sorted","","<strong>O(n(log(max(data)))</strong>, return stable sorted data.",null,[[],[["integer",8],["usize",15],["copy",8],["vec",3],["asprimitive",8]]]],[5,"radix_sorted_with","","<strong>O(n(log(max(f(data))))</strong>, return stable sorted data.",null,[[],["vec",3]]],[0,"knapsack","aclib","",null,null],[0,"dp","aclib::knapsack","",null,null],[5,"knapsack_dp_value","aclib::knapsack::dp","<strong>O(sum(v)n)</strong>, knapsack capacity is c, value of pi is v[i], …",null,[[["usize",15],["integer",8],["copy",8]],[["vec",3],["vec",3]]]],[5,"knapsack_dp_value_solve","","<strong>O(sum(v)n)</strong>, solve knapsack with value-dp",null,[[["usize",15],["integer",8],["copy",8]],["usize",15]]],[5,"knapsack_dp_weight","","<strong>O(cn)</strong>, knapsack capacity is c, value of pi is v[i], …",null,[[["usize",15]],[["vec",3],["vec",3]]]],[5,"dp_weight_with_backtrack","","<strong>O(cn)</strong>, compute vec of products from table made by …",null,[[["usize",15]],[["usize",15],["vec",3]]]],[0,"meet_in_the_middle","aclib::knapsack","",null,null],[5,"knapsack_half_enumerate","aclib::knapsack::meet_in_the_middle","<strong>O(2^(n/2))</strong>, knapsack capacity is c, value of pi is v[i], …",null,[[["usize",15]]]],[0,"solver","aclib::knapsack","",null,null],[5,"knapsack","aclib::knapsack::solver","",null,[[["usize",15]]]],[0,"macros","aclib","",null,null],[0,"compare","aclib::macros","",null,null],[0,"summation","","",null,null],[14,"max","aclib","<strong>O(n)</strong>, max for one or more values",null,null],[14,"min","","<strong>O(n)</strong>, min for one or more values",null,null],[14,"sum","","<strong>O(n)</strong>, sum for values",null,null],[14,"prod","","<strong>O(n)</strong>, prod for values",null,null],[14,"mean","","<strong>O(n)</strong>, average for values",null,null],[11,"from","aclib::collections::linkedlist::singly","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"vzip","","",1,[[]]],[11,"from","aclib::collections::segtree::lazy_segtree::addtree","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"vzip","","",2,[[]]],[11,"from","aclib::collections::segtree::non_copy","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"vzip","","",3,[[]]],[11,"from","aclib::collections::segtree::non_recursive","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"vzip","","",4,[[]]],[11,"from","aclib::collections::segtree::recursive","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"vzip","","",5,[[]]],[11,"from","aclib::collections::segtree::segtree","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"vzip","","",7,[[]]],[11,"from","aclib::collections::sorted_vec","",8,[[]]],[11,"into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"vzip","","",8,[[]]],[11,"from","aclib::collections::trie_tree","",9,[[]]],[11,"into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"vzip","","",9,[[]]],[11,"from","aclib::collections::unionfind::smooth_unionfind","",10,[[]]],[11,"into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"vzip","","",10,[[]]],[11,"from","aclib::collections::unionfind::unionfind","",11,[[]]],[11,"into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"vzip","","",11,[[]]],[11,"from","aclib::cumsum::cumsum1d","",12,[[]]],[11,"into","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"vzip","","",12,[[]]],[11,"from","aclib::cumsum::imos1d","",13,[[]]],[11,"into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"vzip","","",13,[[]]],[11,"from","aclib::graph::without_petgraph::dijkstra","",18,[[]]],[11,"into","","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"equivalent","","",18,[[],["bool",15]]],[11,"vzip","","",18,[[]]],[11,"from","aclib::graph::without_petgraph::structure","",19,[[]]],[11,"into","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"vzip","","",19,[[]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"vzip","","",20,[[]]],[11,"from","","",21,[[]]],[11,"into","","",21,[[]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"vzip","","",21,[[]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"vzip","","",14,[[]]],[11,"from","","",15,[[]]],[11,"into","","",15,[[]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"vzip","","",15,[[]]],[11,"from","aclib::integer::counting","",16,[[]]],[11,"into","","",16,[[]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"vzip","","",16,[[]]],[11,"from","aclib::integer::prime","",17,[[]]],[11,"into","","",17,[[]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"vzip","","",17,[[]]],[11,"drop","aclib::collections::linkedlist::singly","<strong>O(n)</strong>, drop remain nodes",1,[[]]],[11,"extend","","<strong>O(n)</strong>, extends items as tails",1,[[["intoiterator",8]]]],[11,"extend","aclib::collections::sorted_vec","<strong>O(n + k log(k))</strong>, extend elements (size k)",8,[[["intoiterator",8]]]],[11,"cmp","aclib::graph::without_petgraph::dijkstra","",18,[[],["ordering",4]]],[11,"eq","","",18,[[["minheaprecord",3]],["bool",15]]],[11,"ne","","",18,[[["minheaprecord",3]],["bool",15]]],[11,"partial_cmp","","",18,[[],[["option",4],["ordering",4]]]],[11,"fmt","aclib::collections::trie_tree","",9,[[["formatter",3]],["result",6]]],[11,"index","aclib::collections::segtree::non_copy","<strong>O(1)...?</strong>, this function seem to make size n temporary …",3,[[]]],[11,"index","aclib::collections::segtree::non_recursive","<strong>O(1)...?</strong>, this function seem to make size n temporary …",4,[[]]],[11,"index","aclib::collections::sorted_vec","<strong>O(size(index))</strong>, get the element(s) of at the index of the …",8,[[]]],[11,"index","aclib::graph::without_petgraph::structure","<strong>O(1)</strong>, get weight of edge",15,[[]]],[11,"index","","<strong>O(1)</strong>, get node\'s neighbors set",15,[[["usize",15]]]],[11,"index_mut","aclib::collections::segtree::non_copy","<strong>O(1)...?</strong>, this function seem to make size n temporary …",3,[[]]],[11,"from_iter","aclib::collections::sorted_vec","<strong>O(n log(n))</strong>, make sorted list from iterator",8,[[["intoiterator",8]]]],[11,"from_iter","aclib::cumsum::cumsum1d","<strong>O(n)</strong>, create n+1 size vec for cumsum from iterator",12,[[["intoiterator",8]]]],[11,"from_iter","","<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed …",12,[[["intoiterator",8]]]],[11,"dijkstra","aclib::graph::without_petgraph::structure","<strong>O((n+m)log(n))</strong>, shortest path number of hops and its …",15,[[["usize",15]]]],[11,"dijkstra","","<strong>O((n+m)log(n))</strong>, shortest path distance and its route, …",15,[[["usize",15]]]],[11,"bfs","","<strong>O(n)</strong>, return breadth first search order",15,[[["usize",15]],[["usize",15],["vec",3]]]],[11,"dfs","","<strong>O(n)</strong>, return depth first search order",15,[[["usize",15]],[["usize",15],["vec",3]]]]],"p":[[8,"Counter"],[3,"LinkedList"],[3,"AddTree"],[3,"SegmentTree"],[3,"SegmentTree"],[3,"SegmentTree"],[8,"Monoid"],[3,"SegmentTree"],[3,"SortedVec"],[3,"TrieTree"],[3,"UnionFind"],[3,"UnionFind"],[3,"CumSum"],[3,"Imos1D"],[4,"Weighted"],[3,"AdjacencyList"],[3,"Counting"],[3,"SieveOfEratosthenes"],[3,"MinHeapRecord"],[4,"Undirected"],[4,"Directed"],[4,"Unweighted"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);