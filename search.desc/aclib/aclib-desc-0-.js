searchState.loadedDescShard("aclib", 0, "Rust practice: Data structure and Algorithms\n<strong>O(n)</strong>, max for one or more values\n<strong>O(n)</strong>, average for values\n<strong>O(n)</strong>, min for one or more values\n<strong>O(n)</strong>, prod for values\n<strong>O(n)</strong>, sum for values\n<strong>O(log(ans))</strong>, find the first index at which false -&gt; true …\n<strong>O(log(n))</strong>, find the leftmost insertion index with key …\n<strong>O(log(n))</strong>, find the leftmost insertion index with key …\n<strong>O(log(n))</strong>, find the rightmost insertion index with key …\n<strong>O(log(n))</strong>, find the rightmost insertion index with key …\n<strong>O(log(ans/unit))</strong>, find the first index (width: <code>unit</code>) at …\n<strong>O(log(end-start))</strong>, return (start, end) that f(end) == true …\n<strong>O(log())</strong>, calculate log_a(x) by ceil (warning: overflow)\n<strong>O(log())</strong>, calculate log_a(x) by floor (warning: overflow)\n<strong>O(log(x))</strong>, calculate square root of x by ceil (warning: …\n<strong>O(log(x))</strong>, calculate square root of x by floor (warning: …\n<strong>O(log(|a|))</strong>, return the last index i such that a[i] &lt;= x\n<strong>O(log(|a|))</strong>, return the first index i such that a[i] &gt;= x\n<strong>O(log(|a|))</strong>, return the first index i such that a[i] &gt; x\n<strong>O(n log(n))</strong>, return compressed vector\n<strong>O(n)</strong>, get hamming distance between a and b such as a.len() …\n<strong>O(nm)</strong>, calculate edit distance between sequence a and …\n<strong>O(n)</strong>, calculate chebyshev distance between two point of …\n<strong>O(1)</strong>, calculate chebyshev distance between two point of …\n<strong>O(n)</strong>, calculate manhattan distance between two point of …\n<strong>O(1)</strong>, calculate manhattan distance between two point of …\n<strong>O(n)</strong>, 45-degree rotation, manhattan distance become to be …\n<strong>O(n log(n))</strong>, calculate inversion number, on data such as …\n<strong>O(n log(n))</strong>, calculate inversion number for deduplicated …\n<strong>O(n^2)</strong>, stable sorted by bubble sort\n<strong>O(n log(n))</strong>, sorted by heap sort\n<strong>O(n + inversion_number(data))</strong>, stable sorted by insertion …\n<strong>O(n log(n))</strong>, stable sorted by merge sort\n<strong>O(n log(n))</strong>, sorted data by quick sort\n<strong>O(n^2)</strong>, stable sorted by selection sort\n<strong>O(n)</strong>, get iterator of two pointer method. (if cond is true …\n<strong>O(1)</strong>, count new element\n<strong>O(1)</strong>, count the number of occurrences of elem\n<strong>O(n)</strong>, count duplicate elements data\n<strong>O(n log(usize::MAX))</strong>, get vec with sorted in descending …\n<strong>O(n)</strong>, new empty counter\n<strong>O(1)</strong>, remove element\n<strong>O(log(n))</strong>, heapify to leaf without recursive\nReturns the argument unchanged.\n<strong>O(n)</strong>, heapify in place (it is well known that bottom-up …\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, return the number of elements in this heap\n<strong>O(1)</strong>, create min heap with operation that return total …\n<strong>O(1)</strong>, peek min item\n<strong>O(log(n))</strong>, pop min item\n<strong>O(log(n))</strong>, push new item\n<strong>O(log(n))</strong>, heapify to root without recursive\n<strong>O(log(n))</strong>, heapify subtree\nReturns the argument unchanged.\n<strong>O(n)</strong>, heapify in place\n<strong>O(n)</strong>, heapify\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, return the number of elements in this heap\n<strong>O(1)</strong>, create min heap with operation that return total …\n<strong>O(1)</strong>, peek min item\n<strong>O(log(n))</strong>, pop min item\n<strong>O(log(n))</strong>, push new item\n<strong>O(log(n))</strong>, heapify to root\n<strong>O(1)</strong>, append the other linked list\n<strong>O(1)</strong>, return and remove head item\n<strong>O(n)</strong>, drop remain nodes\n<strong>O(1)</strong>, add new item to the end of the list\n<strong>O(n)</strong>, extends items as tails\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, return true if the list has no item, else return …\n<strong>O(1)</strong>, return length of the list\n<strong>O(1)</strong>, return empty linked list\n<strong>O(1)</strong>, peek the top of the list\n<strong>O(1)</strong>, peek the end of the list\n<strong>O(1)</strong>, return and remove head item\n<strong>O(1)</strong>, add new item to the top of the list\n<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …\nwrap input to Monoid\nReturns the argument unchanged.\nidentity element of Monoid\n<strong>O(1)</strong>, range to leaf index half interval [left, right).\nunwrap from monoid\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, get beginning index of the segment tree leaf.\n<strong>O(1)</strong>, return this segtree ’s number of data\n<strong>O(n)</strong>, create segment tree. (e is identity element for a …\nbinary operation that satisfy associative law for Monoid\n<strong>O(log(n))</strong>, calculate f(range). (non-recursive)\n<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …\n<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, get beginning index of the segment tree leaf.\n<strong>O(n)</strong>, create segment tree. (e is identity element for a …\n<strong>O(1)</strong>, get size of leaves\n<strong>O(log(n))?</strong>, propagate lazy value to children\n<strong>O(log^2(n))?</strong>, calculate half-open interval summation from …\n<strong>O(log^2(n))?</strong>, calculate summation from root to leaf.\n<strong>O(log^2(n))?</strong>, set lazy value from root to leaf\n<strong>O(log(n))</strong>, update the half interval [l, r) with add x.\n<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …\n<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …\n<strong>O(n)</strong>, create segment tree, note that this method requires …\nReturns the argument unchanged.\n<strong>O(1)…?</strong>, this function seem to make size n temporary …\n<strong>O(1)…?</strong>, this function seem to make size n temporary …\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, get beginning index of the segment tree leaf.\n<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …\n<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …\n<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …\n<strong>O(log(n))</strong>, update segment tree. (non-recursive)\n<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …\n<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …\n<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …\nReturns the argument unchanged.\n<strong>O(1)…?</strong>, this function seem to make size n temporary …\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, get beginning index of the segment tree leaf.\n<strong>O(n)</strong>, create segment tree. (e is identity element for a …\n<strong>O(1)</strong>, get size of leaves\n<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …\n<strong>O(log(n))</strong>, swap leaf[k] and leaf[l], and update segment …\n<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …\n<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …\n<strong>O(log^2(n))</strong>, search the leftmost leaf where cmp(x) is true …\n<strong>O(log^2(n))</strong>, search the rightmost leaf where cmp(x) is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, either node x is root or not.\n<strong>O(1)</strong>, get beginning index of the segment tree leaf.\n<strong>O(1)</strong>, get left child index of node x.\n<strong>O(n)</strong>, create segment tree. (e is identity element for a …\n<strong>O(1)</strong>, get size of leaves.\n<strong>O(1)</strong>, get parent index of node x.\n<strong>O(log(n))</strong>, calculate f(l, l+1, …, r-1). note the half …\n<strong>O(log(n)-log(node))</strong>, calculate from root to leaf.\n<strong>O(log(i))</strong>, update from leaf to root.\n<strong>O(1)</strong>, get right child index of node x.\n<strong>O(1)</strong>, get root index.\n<strong>O(log(n))</strong>, update segment tree, leaf[k] = x.\n<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …\n<strong>O(log^2(n))</strong>, search the leaf where cmp(x) is true in half …\nReturns the argument unchanged.\nidentity element of Monoid\n<strong>O(1)</strong>, range to leaf index half interval [left, right).\nunwrap monoid for return value\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, get beginning index of the segment tree leaf.\n<strong>O(1)</strong>, return this segtree ’s number of data\n<strong>O(n)</strong>, create segment tree. (e is identity element for a …\nbinary operation that satisfy associative law for Monoid\n<strong>O(log(n))</strong>, calculate f(range). (non-recursive)\n<strong>O(log(n))</strong>, set leaf[k] = x, and update segment tree. …\n<strong>O(log(n))</strong>, update leaf[k] by f(leaf[k]), and update …\nshould use binary search tree\n<strong>O(n + k log(k))</strong>, extend elements (size k)\nReturns the argument unchanged.\n<strong>O(n log(n))</strong>, make sorted list from iterator\n<strong>O(size(index))</strong>, get the element(s) of at the index of the …\n<strong>O(n)</strong>, insert element\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, get iterator of vec\n<strong>O(k)</strong>, max k elements\n<strong>O(k)</strong>, min k elements\n<strong>O(1)</strong>, get empty vec\n<strong>O(m)</strong>, judge key is inserted or not\nReturns the argument unchanged.\n<strong>O(m)</strong>, insert key\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, make empty trie tree\n<strong>O(m)</strong>, remove key (WARNING: unimplemented!)\nexample of how to use petgraph::unionfind::Unionfind\n<strong>O(log(n))</strong>, find the root of x, and update the roots of …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(n)</strong>, create n trees with themselves as roots\n<strong>O(log(n))</strong>, return members in same group (warning: returned …\n<strong>O(log(n))</strong>, return number of members in same group\n<strong>O(log(n))</strong>, marge a’s trees and b’s tree, if already …\n<strong>O(n log(n))</strong>, get connected components (HashMap&lt;parent, …\n<strong>O(log(n))</strong>, check does x and y belong same root\n<strong>O(log(n))</strong>, find the root of x, and update the roots of …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(n)</strong>, create n trees with themselves as roots\n<strong>O(log(n))</strong>, get root of x, this method is immutable\n<strong>O(log(n))</strong>, return size of connected component\n<strong>O(log(n))</strong>, marge 2 trees with primary and standby roots, …\n<strong>worst: O(n)</strong>, find the root of x\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(n)</strong>, create n trees with themselves as roots\n<strong>worst: O(n)</strong>, marge 2 trees with primary and standby roots\nReturns the argument unchanged.\n<strong>O(n)</strong>, create n+1 size vec for cumsum from iterator\n<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed iterator\n<strong>O(1)</strong>, range to index half interval [left, right).\n<strong>O(1)</strong>, calculate half-open interval summation r\nCalls <code>U::from(self)</code>.\n<strong>O(n)</strong>, create n+1 size vec for cumsum from borrowed iterator\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(n)</strong>, create n+1 size vec for imos 1d\n<strong>O(1)</strong>, calculate sum of timing t\n<strong>O(|candidate| * (kinds of chars)^2)</strong>, generate the kth item …\n<strong>O(n)</strong>, generate next item in dictionary order, in place\n<strong>O((n+m)log(n))</strong>, shortest paths cost, with dijkstra …\n<strong>O((n+m)log(n))</strong>, shortest path cost, with dijkstra algorithm\n<strong>O(n+m)</strong>, get visited time and left time by dfs\nexample of how to use petgraph::Graph::from_edges\n<em><strong>O(m log(n))</strong></em>, check bipartite graph (warning: expect simple …\n<strong>O(n)</strong>, return diameter of given tree\n<strong>O(hw)</strong>, make directed grid like graph from map (‘.’ is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nweighted/unweighted and directed/undirected graph structure\n<strong>O(1)</strong>, add node and return its index\n<strong>O(n)</strong>, return breadth first search order\n<strong>O(n)</strong>, return depth first search order\n<strong>O((n+m)log(n))</strong>, shortest path distance and its route, with …\n<strong>O((n+m)log(n))</strong>, shortest path number of hops and its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<strong>O(1)</strong>, get node’s neighbors set\n<strong>O(1)</strong>, get weight of edge\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, get node’s neighbors set reference\n<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) to …\n<strong>O(m)</strong>, convert sequence of edges(unweighted, undirected) to …\n<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …\n<strong>O(m)</strong>, convert sequence of edges(weighted, undirected) to …\n<strong>O(1)</strong>, number of nodes\n<strong>O(1)</strong>, remove node and return its neighbors if possible  …\n<strong>O(1)</strong>, get weight of edge\n<strong>O(1)</strong>, compute nCk mod p\n<strong>O(1)</strong>, compute nHk mod p\n<strong>O(1)</strong>, compute n! mod p\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(n)</strong>, ready to compute combination(n,k) mod p, where p is …\n<strong>O(1)</strong>, compute nPk mod p\n<strong>O(sqrt(n))</strong>, calculate vec of devisors\n<strong>O(sqrt(n))</strong>, calculate vec of pair os devisors\n<strong>O(|v| log(min(v))</strong>, calculate gcd recursively\n<strong>O(|v| log(min(v)))</strong>, calculate lcm recursively\nprime number is calculated as a index of Vec, so their …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, if num is prime then return true, else return false\n**O((r - l)log(log(r)) + sqrt(r))*, Sieve primes in the …\n<strong>O(n)</strong>, calculate vec of primes from <code>[l, r]</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(log(min(a, b)))</strong>, calculate pair (gcd(a,b), x, y) such …\n<strong>O(log(min(a, modulo)))</strong>, calculate inverse element of a in …\n<strong>O(log(b))</strong>, calculate a^b % modulo\n<strong>O(log(b))</strong>, calculate a^b % modulo\n<strong>O(sqrt(n))</strong>, calculate prime factorization of n\n<strong>O(n)…?</strong>, calculate vec of primes from 0 to max\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nprime number is calculated as a index of Vec, so their …\n<strong>O(n log(log(n)))</strong>, calculate all prime factorization of …\n<strong>O(log(n))</strong>, the number of integers that are prime to n each …\n<strong>O(log(n))</strong>, calculate prime factorization of n, with …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>O(1)</strong>, if num is prime then return true, else return false\n<strong>O(n log(log(n)))</strong>, calculate size n+1 sieve, which vec[i] …\n<strong>O(n)</strong>, calculate vec of primes from 0 to max\n<strong>O(n)</strong>, returned vec[i] mean i is prime or not\n<strong>O(n + (max(data)-min(data)))</strong>, return stable sorted data.\n<strong>O(n + (max(f(data))-min(f(data))))</strong>, return stable sorted …\n<strong>O(n(log(max(data)))</strong>, return stable sorted data.\n<strong>O(n(log(max(f(data))))</strong>, return stable sorted data.\n<strong>O(cn)</strong>, compute vec of products from table made by …\n<strong>O(sum(v)n)</strong>, knapsack capacity is c, value of pi is v[i], …\n<strong>O(sum(v)n)</strong>, solve knapsack with value-dp\n<strong>O(cn)</strong>, knapsack capacity is c, value of pi is v[i], weight …\n<strong>O(2^(n/2))</strong>, knapsack capacity is c, value of pi is v[i], …")